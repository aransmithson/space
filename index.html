<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Orbital Surface Simulation</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; }
body { margin:0; overflow:hidden; background:#000; font-family:'Share Tech Mono', monospace; cursor:crosshair; }
canvas { display:block; }

#hud {
    position:fixed;
    top:20px;
    left:20px;
    width:220px;
    pointer-events:none;
    z-index:10;
}
#hud h2 {
    font-family:'Orbitron', sans-serif;
    font-size:10px;
    letter-spacing:4px;
    color:#aaa;
    margin:0 0 12px 0;
    text-transform:uppercase;
}
.res-row { margin-bottom:10px; }
.res-label {
    font-size:10px;
    letter-spacing:2px;
    color:#888;
    display:flex;
    justify-content:space-between;
    margin-bottom:3px;
}
.res-label span:last-child { color:#ccc; }
.res-track {
    width:100%;
    height:6px;
    background:rgba(255,255,255,0.07);
    border-radius:3px;
    overflow:hidden;
    position:relative;
}
.res-fill {
    height:100%;
    border-radius:3px;
    transition:width 0.3s ease;
    position:relative;
}
.res-fill::after {
    content:'';
    position:absolute;
    right:0; top:0; bottom:0;
    width:3px;
    background:rgba(255,255,255,0.6);
    border-radius:3px;
}
.critical .res-fill { animation: pulse-bar 0.5s ease-in-out infinite alternate; }
@keyframes pulse-bar {
    from { opacity:1; }
    to { opacity:0.4; }
}
.status-row {
    margin-top:8px;
    font-size:9px;
    letter-spacing:2px;
    color:#555;
    text-transform:uppercase;
}
.status-row .status-val { color:#0af; }
#zoom-hint {
    position:fixed;
    bottom:20px;
    right:20px;
    font-size:9px;
    letter-spacing:2px;
    color:#2a2a2a;
    pointer-events:none;
    z-index:10;
}
#gameover {
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.75);
    z-index:100;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    text-align:center;
}
#gameover.active { display:flex; }
#gameover h1 {
    font-family:'Orbitron', sans-serif;
    font-size:28px;
    letter-spacing:6px;
    color:#ff3344;
    margin:0 0 12px 0;
    text-transform:uppercase;
}
#gameover p {
    font-size:11px;
    letter-spacing:3px;
    color:#777;
    margin:0 0 28px 0;
    text-transform:uppercase;
}
#gameover button {
    font-family:'Share Tech Mono', monospace;
    font-size:11px;
    letter-spacing:3px;
    text-transform:uppercase;
    background:none;
    border:1px solid #0af;
    color:#0af;
    padding:10px 28px;
    cursor:pointer;
}
#gameover button:hover { background:rgba(0,170,255,0.1); }
</style>
</head>
<body>
<canvas id="sim"></canvas>

<div id="hud">
    <h2>Ship Status</h2>
    <div class="res-row" id="row-oxygen">
        <div class="res-label"><span>OXYGEN</span><span id="val-oxygen">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-oxygen" style="background:#00bbff;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-water">
        <div class="res-label"><span>WATER</span><span id="val-water">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-water" style="background:#3366ff;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-food">
        <div class="res-label"><span>FOOD</span><span id="val-food">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-food" style="background:#44dd77;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-fuel">
        <div class="res-label"><span>FUEL</span><span id="val-fuel">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-fuel" style="background:#ffaa00;width:100%"></div></div>
    </div>
    <div class="status-row">STATE: <span class="status-val" id="state-label">STANDBY</span></div>
    <div class="status-row">TARGET: <span class="status-val" id="target-label">—</span></div>
    <div style="margin-top:12px; pointer-events:auto;">
    <button id="follow-btn" style="
        width:100%;
        font-family:'Share Tech Mono', monospace;
        font-size:10px;
        letter-spacing:2px;
        text-transform:uppercase;
        background:none;
        border:1px solid #0af;
        color:#0af;
        padding:6px;
        cursor:pointer;">
        Follow Camera: OFF
    </button>
</div>

</div>

<div id="zoom-hint">SCROLL TO ZOOM &nbsp;·&nbsp; DRAG TO PAN</div>

<div id="gameover">
    <h1>Mission Failed</h1>
    <p id="gameover-reason">Critical resource depleted</p>
    <button onclick="location.reload()">Restart Mission</button>
</div>

<script>
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

// =============================
// CAMERA
// =============================
const camera = { 
    zoom: 1, 
    panX: 0, 
    panY: 0,
    follow: false
};


canvas.addEventListener("wheel", e => {
    e.preventDefault();
    const f = e.deltaY < 0 ? 1.12 : 0.89;
    const mx = e.clientX - canvas.width / 2;
    const my = e.clientY - canvas.height / 2;
    camera.panX = camera.panX * f + mx * (1 - f);
    camera.panY = camera.panY * f + my * (1 - f);
    camera.zoom = Math.max(0.2, Math.min(14, camera.zoom * f));
}, { passive: false });

let dragging = false, dragStart = {x:0,y:0}, panStart = {x:0,y:0};
canvas.addEventListener("mousedown", e => {
    dragging = true;
    dragStart = { x: e.clientX, y: e.clientY };
    panStart  = { x: camera.panX, y: camera.panY };
});
canvas.addEventListener("mousemove", e => {
    if(!dragging || camera.follow) return;
    camera.panX = panStart.x + (e.clientX - dragStart.x);
    camera.panY = panStart.y + (e.clientY - dragStart.y);
});
window.addEventListener("mouseup", () => dragging = false);

function applyCamera(){
    ctx.translate(canvas.width/2 + camera.panX, canvas.height/2 + camera.panY);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-canvas.width/2, -canvas.height/2);
}
const followBtn = document.getElementById("follow-btn");

followBtn.addEventListener("click", () => {
    camera.follow = !camera.follow;

    followBtn.textContent = 
        "Follow Camera: " + (camera.follow ? "ON" : "OFF");

    if(camera.follow){
        camera.panX = 0;
        camera.panY = 0;
    }
});


// =============================
// RESIZE + STARS
// =============================
let stars = [];
function buildStars(){
    stars = [];
    for(let i = 0; i < 350; i++){
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: Math.random() * 1.3 + 0.2,
            a: Math.random() * 0.7 + 0.3,
            tw: Math.random() * 3 + 1
        });
    }
}
function resize(){
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    buildStars();
}
window.addEventListener("resize", resize);
resize();

function center(){ return { x: canvas.width/2, y: canvas.height/2 }; }

function randRange(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
}


function drawStars(t){
    for(let s of stars){
        const twinkle = 0.6 + 0.4 * Math.sin(t / 1000 * s.tw);
        ctx.globalAlpha = s.a * twinkle;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// =============================
// COLOR UTILS
// =============================
function shiftColor(hex, amt){
    let r, g, b;
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    if(m){ r=parseInt(m[1],16); g=parseInt(m[2],16); b=parseInt(m[3],16); }
    else {
        const tmp=document.createElement('canvas'); tmp.width=tmp.height=1;
        const tc=tmp.getContext('2d'); tc.fillStyle=hex; tc.fillRect(0,0,1,1);
        const d=tc.getImageData(0,0,1,1).data; r=d[0];g=d[1];b=d[2];
    }
    r=Math.min(255,Math.max(0,Math.round(r+amt*255)));
    g=Math.min(255,Math.max(0,Math.round(g+amt*255)));
    b=Math.min(255,Math.max(0,Math.round(b+amt*255)));
    return `rgb(${r},${g},${b})`;
}
const lighten = (h, a) => shiftColor(h,  a);
const darken  = (h, a) => shiftColor(h, -a);

// =============================
// SUN
// =============================
function drawSun(t){
    const c = center();
    const pulse = 1 + 0.02 * Math.sin(t / 600);

    for(let i = 3; i > 0; i--){
        const grad = ctx.createRadialGradient(c.x, c.y, 24, c.x, c.y, 40*i*pulse);
        grad.addColorStop(0, 'rgba(255,200,50,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 40*i*pulse, 0, Math.PI*2);
        ctx.fill();
    }

    const sunGrad = ctx.createRadialGradient(c.x-8, c.y-8, 4, c.x, c.y, 28*pulse);
    sunGrad.addColorStop(0, '#fff8c0');
    sunGrad.addColorStop(0.4, '#ffcc00');
    sunGrad.addColorStop(1, '#ff6600');
    ctx.fillStyle = sunGrad;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 28*pulse, 0, Math.PI*2);
    ctx.fill();
}

// =============================
// PLANETS
// =============================
function hexToRgba(hex, a){
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    return m ? `rgba(${parseInt(m[1],16)},${parseInt(m[2],16)},${parseInt(m[3],16)},${a})` : hex;
}

class Planet {
    constructor(name, orbitFactor, size, color, resource, glowColor){
        this.name = name;
        this.orbitFactor = orbitFactor;
        this.size = size;
        this.color = color;
        this.glowColor = glowColor || color;
        this.glowRGBA = hexToRgba(this.glowColor, 0.2);
        this.resource = resource;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 0.00005 + Math.random() * 0.00003;
    }

    orbitRadius(){
        return Math.min(canvas.width, canvas.height) / 2 * this.orbitFactor;
    }

    update(dt){ this.angle += this.speed * dt; }

    position(){
        const c = center();
        const r = this.orbitRadius();
        return { x: c.x + Math.cos(this.angle)*r, y: c.y + Math.sin(this.angle)*r };
    }

    draw(t){
        const p  = this.position();
        const c  = center();
        const r  = this.orbitRadius();

        // Orbit ring
        ctx.beginPath();
        ctx.arc(c.x, c.y, r, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.04)";
        ctx.lineWidth = 1 / camera.zoom;
        ctx.stroke();

        // Atmosphere glow
        const pulse = 1 + 0.04 * Math.sin(t / 800);
        const grad = ctx.createRadialGradient(p.x, p.y, this.size*0.5, p.x, p.y, this.size*3*pulse);
        grad.addColorStop(0, this.glowRGBA);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.beginPath();
        ctx.arc(p.x, p.y, this.size*3*pulse, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Planet body
        const bg = ctx.createRadialGradient(p.x - this.size*0.3, p.y - this.size*0.3, this.size*0.1, p.x, p.y, this.size);
        bg.addColorStop(0, lighten(this.color, 0.4));
        bg.addColorStop(1, darken(this.color, 0.4));
        ctx.fillStyle = bg;
        ctx.beginPath();
        ctx.arc(p.x, p.y, this.size, 0, Math.PI*2);
        ctx.fill();

        // Label
        ctx.save();
        ctx.font = `${9 / camera.zoom}px 'Share Tech Mono'`;
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.textAlign = "center";
        ctx.fillText(this.name.toUpperCase(), p.x, p.y + this.size + 14 / camera.zoom);
        ctx.restore();
    }
}

const planets = [
    new Planet("Oxygen", 0.28, 14, "#00aaff", "oxygen", "#00aaff"),
    new Planet("Food",   0.46, 15, "#44cc66", "food",   "#44cc66"),
    new Planet("Water",  0.67, 13, "#2255dd", "water",  "#2255dd"),
    new Planet("Fuel",   0.90, 17, "#dd8800", "fuel",   "#dd8800"),
];

// =============================
// THRUST TRAIL
// =============================
class Trail {
    constructor(){ this.particles = []; }

    emit(x, y, vx, vy, color){
        for(let i = 0; i < 3; i++){
            this.particles.push({
                x, y,
                vx: vx * -0.08 + (Math.random()-0.5) * 0.8,
                vy: vy * -0.08 + (Math.random()-0.5) * 0.8,
                life: 1,
                decay: 0.025 + Math.random() * 0.02,
                size: 0.6 + Math.random() * 0.8,
                color
            });
        }
    }

    update(dt){
        for(let p of this.particles){
            p.x += p.vx * dt * 0.1;
            p.y += p.vy * dt * 0.1;
            p.life -= p.decay * dt * 0.1;
        }
        this.particles = this.particles.filter(p => p.life > 0);
    }

    draw(){
        for(let p of this.particles){
            ctx.globalAlpha = p.life * 0.7;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

const trail = new Trail();

// =============================
// SPAWN BURST
// =============================
const spawnParticles = [];

function triggerSpawn(x, y){
    const colors = ['#ffffff','#00ccff','#88eeff','#ffcc44','#ff8833','#aaffcc'];

    for(let i = 0; i < 140; i++){
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 5;

        spawnParticles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            decay: 0.002 + Math.random() * 0.004,
            size: 1.2 + Math.random() * 3.5,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }

    // Flash ring effect
    spawnParticles.push({
        x, y,
        vx: 0,
        vy: 0,
        life: 1,
        decay: 0.01,
        size: 40,
        color: 'rgba(255,255,255,0.5)',
        ring: true
    });
}


function updateSpawnParticles(dt){
    for(let p of spawnParticles) {
        p.x += p.vx * dt * 0.1;
        p.y += p.vy * dt * 0.1;
        p.vx *= 0.97;
        p.vy *= 0.97;
        p.life -= p.decay * dt * 0.1;
    }
    for(let i = spawnParticles.length - 1; i >= 0; i--)
        if(spawnParticles[i].life <= 0) spawnParticles.splice(i, 1);
}

function drawSpawnParticles(){
    for(let p of spawnParticles){
        if(p.life <= 0) continue;

        ctx.globalAlpha = p.life;

        if(p.ring){
            ctx.strokeStyle = p.color;
            ctx.lineWidth = 3 * p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (1 - p.life) + 10, 0, Math.PI*2);
            ctx.stroke();
        } else {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1;
}


// =============================
// DUST / PLUME PARTICLE SYSTEM
// =============================
const dustParticles = [];

function emitLandingDust(planet, surfaceAngle){
    const pp = planet.position();
    const sx = pp.x + Math.cos(surfaceAngle) * planet.size;
    const sy = pp.y + Math.sin(surfaceAngle) * planet.size;

    const dustColors = [
        hexToRgba(planet.color, 0.6),
        hexToRgba(planet.color, 0.3),
        'rgba(200,200,200,0.4)',
        'rgba(255,255,255,0.25)',
        hexToRgba(planet.color, 0.15),
    ];

    for(let i = 0; i < 45; i++){
        // Spread dust along the surface tangent (perpendicular to surface normal)
        const tangent = surfaceAngle + Math.PI / 2;
        const spread = (Math.random() - 0.5) * 2.2;
        const outward = 0.3 + Math.random() * 1.8;
        const vx = Math.cos(surfaceAngle) * outward * 0.4 + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * outward * 0.4 + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 4,
            y: sy + (Math.random() - 0.5) * 4,
            vx, vy,
            life: 1,
            decay: 0.006 + Math.random() * 0.008,
            size: 1.0 + Math.random() * 3.5,
            color: dustColors[Math.floor(Math.random() * dustColors.length)]
        });
    }
}

function emitTakeoffBlast(planet, surfaceAngle){
    const pp = planet.position();
    const sx = pp.x + Math.cos(surfaceAngle) * (planet.size + 2);
    const sy = pp.y + Math.sin(surfaceAngle) * (planet.size + 2);

    // Fiery exhaust colors
    const fireColors = [
        'rgba(255,200,60,0.9)',
        'rgba(255,140,30,0.8)',
        'rgba(255,80,10,0.7)',
        'rgba(255,255,200,0.6)',
        'rgba(255,100,50,0.5)',
    ];

    // Dust kicked up by takeoff
    const dustColors = [
        hexToRgba(planet.color, 0.5),
        'rgba(200,200,200,0.3)',
        hexToRgba(planet.color, 0.2),
    ];

    // Fire blast downward (into planet surface)
    for(let i = 0; i < 35; i++){
        const tangent = surfaceAngle + Math.PI / 2;
        const spread = (Math.random() - 0.5) * 1.5;
        // Particles go inward (opposite of surface normal) to simulate exhaust hitting ground
        const inward = -(0.5 + Math.random() * 2.0);
        const vx = Math.cos(surfaceAngle) * inward * 0.3 + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * inward * 0.3 + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 3,
            y: sy + (Math.random() - 0.5) * 3,
            vx, vy,
            life: 1,
            decay: 0.008 + Math.random() * 0.012,
            size: 0.8 + Math.random() * 2.5,
            color: fireColors[Math.floor(Math.random() * fireColors.length)]
        });
    }

    // Surface dust blowing outward along tangent
    for(let i = 0; i < 30; i++){
        const tangent = surfaceAngle + Math.PI / 2;
        const dir = Math.random() > 0.5 ? 1 : -1;
        const spread = dir * (0.8 + Math.random() * 2.5);
        const outward = 0.1 + Math.random() * 0.6;
        const vx = Math.cos(surfaceAngle) * outward + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * outward + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 6,
            y: sy + (Math.random() - 0.5) * 6,
            vx, vy,
            life: 1,
            decay: 0.004 + Math.random() * 0.006,
            size: 1.5 + Math.random() * 3.0,
            color: dustColors[Math.floor(Math.random() * dustColors.length)]
        });
    }
}

function updateDustParticles(dt){
    for(let p of dustParticles){
        p.x += p.vx * dt * 0.08;
        p.y += p.vy * dt * 0.08;
        p.vx *= 0.96;
        p.vy *= 0.96;
        p.life -= p.decay * dt * 0.1;
    }
    for(let i = dustParticles.length - 1; i >= 0; i--)
        if(dustParticles[i].life <= 0) dustParticles.splice(i, 1);
}

function drawDustParticles(){
    for(let p of dustParticles){
        if(p.life <= 0) continue;
        ctx.globalAlpha = p.life * 0.8;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (0.4 + p.life * 0.6), 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// =============================
// PACKAGE (spawns on planet)
// =============================
class Package {
    constructor(){
        this.active = false;
        this.planet = null;
        this.surfaceAngle = 0;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.spawnAnim = 0; // 0 to 1 pop-in animation
    }

    spawn(planet, shipSurfaceAngle){
    this.active = true;
    this.planet = planet;
    this.spawnAnim = 0;

    // Fully random angle
    let angle;
    let attempts = 0;

    do {
        angle = Math.random() * Math.PI * 2;
        attempts++;
        // Keep trying if too close to landing site
    } while(
        attempts < 30 &&
        Math.abs(angleDiff(angle, shipSurfaceAngle)) < 0.9   // ~50 degrees away
    );

    this.surfaceAngle = angle;

    // Trigger visible spawn burst on surface
    const pp = planet.position();
    const r = planet.size + 6;

    const sx = pp.x + Math.cos(this.surfaceAngle) * r;
    const sy = pp.y + Math.sin(this.surfaceAngle) * r;

    triggerSpawn(sx, sy);
}


    dismiss(){
        this.active = false;
        this.planet = null;
    }

    update(dt){
        if(!this.active) return;
        this.bobPhase += dt * 0.004;
        if(this.spawnAnim < 1) this.spawnAnim = Math.min(1, this.spawnAnim + dt * 0.004);
    }

    draw(t){
        if(!this.active) return;

        const pp = this.planet.position();
        const r = this.planet.size + 6;
        const bob = Math.sin(this.bobPhase) * 1.5;

        const x = pp.x + Math.cos(this.surfaceAngle) * (r + bob);
        const y = pp.y + Math.sin(this.surfaceAngle) * (r + bob);

        // Eased pop-in scale
        const ease = 1 - Math.pow(1 - this.spawnAnim, 3);
        const scale = ease * 0.22;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.surfaceAngle + Math.PI / 2);
        ctx.scale(scale, scale);

        // Glow underneath
        const glow = ctx.createRadialGradient(0, 0, 2, 0, 0, 30);
        glow.addColorStop(0, 'rgba(255,220,80,0.4)');
        glow.addColorStop(1, 'rgba(255,220,80,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI * 2);
        ctx.fill();

        // Crate body
        ctx.fillStyle = "#cc8800";
        ctx.strokeStyle = "#aa6600";
        ctx.lineWidth = 2;
        if(ctx.roundRect){
            ctx.beginPath();
            ctx.roundRect(-12, -20, 24, 22, 3);
            ctx.fill();
            ctx.stroke();
        } else {
            ctx.fillRect(-12, -20, 24, 22);
            ctx.strokeRect(-12, -20, 24, 22);
        }

        // Crate highlight
        ctx.fillStyle = "rgba(255,200,0,0.5)";
        ctx.fillRect(-8, -16, 16, 14);

        // Crate cross straps
        ctx.strokeStyle = "#886600";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-12, -20); ctx.lineTo(12, 2);
        ctx.moveTo(12, -20); ctx.lineTo(-12, 2);
        ctx.stroke();

        // Resource icon dot (glowing)
        const resColors = { oxygen:'#00ccff', water:'#4488ff', food:'#44dd77', fuel:'#ffaa00' };
        const rc = resColors[this.planet.resource] || '#fff';
        ctx.fillStyle = rc;
        ctx.shadowColor = rc;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, -9, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

const pkg = new Package();

// =============================
// ANGLE UTILS
// =============================
function lerpAngle(current, target, t){
    let diff = target - current;
    while(diff >  Math.PI) diff -= Math.PI * 2;
    while(diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * t;
}

function angleDiff(a, b){
    let d = b - a;
    while(d >  Math.PI) d -= Math.PI * 2;
    while(d < -Math.PI) d += Math.PI * 2;
    return d;
}

// =============================
// SHIP
// =============================
class Ship {
    constructor(){
        const c = center();
        this.x = c.x;
        this.y = c.y - 200;
        this.vx = 0;
        this.vy = 0;
        this.rotation = 0;
        this.thrusting = false;
        // Loading phase
        this.loadingTimer = 0;
        this.loadingResource = null;
        this.loadingDuration = 2000; // 2 seconds

        this.state = "idle";
        this.target = null;
        this.landedPlanet = null;
        this.surfaceAngle = 0;

        this.resources = {
            oxygen: randRange(50, 100),
            water:  randRange(50, 100),
            food:   randRange(50, 100),
            fuel:   randRange(50, 100)
        };
        this.evaRefillRate = 0;
        this.evaResource = null;

        // Spawn
        this.spawned = false;
        this.spawnTimer = 0;
        this.SPAWN_DELAY = 1200;

        // Takeoff effect
        this.takeoffTimer = 0;
        this.takeoffBlastEmitted = false;

        // Idle wander
        this.wanderX = 0;
        this.wanderY = 0;
        this._pickWander();
                // Smooth landing
        this.landingProgress = 0;

        // Prevent repeat planet visits
        this.lastPlanet = null;

    }

    _pickWander(){
        const pad = 280;
        this.wanderX = pad + Math.random() * (canvas.width  - pad*2);
        this.wanderY = pad + Math.random() * (canvas.height - pad*2);
    }

    update(dt){
        // Spawn countdown
        if(!this.spawned){
            this.spawnTimer += dt;
            if(this.spawnTimer >= this.SPAWN_DELAY){
                this.spawned = true;
                triggerSpawn(this.x, this.y);
            }
            return;
        }

        // RESOURCE DRAIN
        let oxygenDrain = 0.0004; // base drain inside ship

        if(this.state === "eva"){
            oxygenDrain = 0.0025; // heavy drain outside
        }
        else if(this.state === "transfer" || this.state === "takeoff"){
            oxygenDrain = 0.0007; // slightly higher under thrust
        }

        this.resources.oxygen -= oxygenDrain * dt;

        this.resources.water -= 0.001 * dt;
        this.resources.food  -= 0.0006 * dt;

        if(this.state === "transfer" || this.state === "takeoff")
            this.resources.fuel -= 0.0015 * dt;


        for(let r in this.resources)
            this.resources[r] = Math.max(0, this.resources[r]);

        // TRANSFER — slow thrust, always tracking moving target
        if(this.state === "transfer"){
            const tp = this.target.position();
            const dx = tp.x - this.x;
            const dy = tp.y - this.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);

            const maxSpeed = 1.4;
            const arriveRadius = 120;
            let desiredSpeed = dist < arriveRadius ? maxSpeed * (dist / arriveRadius) : maxSpeed;

            const desiredVX = Math.cos(angle) * desiredSpeed;
            const desiredVY = Math.sin(angle) * desiredSpeed;

            const steerStrength = 0.08;
            this.vx += (desiredVX - this.vx) * steerStrength;
            this.vy += (desiredVY - this.vy) * steerStrength;

            this.thrusting = dist > this.target.size + 10;
            if(this.thrusting){
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
            }

            if(dist <= this.target.size + 6){
                this.land();
            }
        }

        // LANDED / EVA — stick to planet surface
        if(this.state === "landed" || this.state === "eva" || this.state === "loading"){
            const pp = this.landedPlanet.position();
            this.x = pp.x + Math.cos(this.surfaceAngle) * this.landedPlanet.size;
            this.y = pp.y + Math.sin(this.surfaceAngle) * this.landedPlanet.size;
            this.rotation = this.surfaceAngle + Math.PI/2;
            this.thrusting = false;
        }
// =============================
// LOADING
// =============================
if(this.state === "loading"){
    this.loadingTimer += dt;

    const progress = this.loadingTimer / this.loadingDuration;

    if(this.loadingResource){
        const type = this.loadingResource;

        // Gradual refill
        this.resources[type] = Math.min(
            100,
            this.resources[type] + 0.05 * dt
        );
    }

    if(progress >= 1){
        this.loadingResource = null;
        this.state = "takeoff";
    }

    this.thrusting = false;
    this.updateHUD();  // ✅ add this
    return;
}

        // TAKEOFF
        if(this.state === "takeoff"){
            this.takeoffTimer += dt;

            // Emit the big takeoff blast once at the start
            if(!this.takeoffBlastEmitted){
                this.takeoffBlastEmitted = true;
                emitTakeoffBlast(this.landedPlanet, this.surfaceAngle);
            }

            // Continuous exhaust during takeoff
            if(this.takeoffTimer % 3 < 2){
                const pp = this.landedPlanet.position();
                const ex = pp.x + Math.cos(this.surfaceAngle) * (this.landedPlanet.size - 1);
                const ey = pp.y + Math.sin(this.surfaceAngle) * (this.landedPlanet.size - 1);
                const tangent = this.surfaceAngle + Math.PI / 2;
                for(let i = 0; i < 2; i++){
                    dustParticles.push({
                        x: this.x, y: this.y,
                        vx: -Math.cos(this.surfaceAngle) * (0.5 + Math.random() * 1.5) + (Math.random()-0.5)*0.5,
                        vy: -Math.sin(this.surfaceAngle) * (0.5 + Math.random() * 1.5) + (Math.random()-0.5)*0.5,
                        life: 1,
                        decay: 0.012 + Math.random() * 0.015,
                        size: 0.6 + Math.random() * 1.8,
                        color: ['rgba(255,180,60,0.8)','rgba(255,100,20,0.6)','rgba(255,220,120,0.7)'][Math.floor(Math.random()*3)]
                    });
                }
            }

            this.vx += Math.cos(this.surfaceAngle) * 0.00012 * dt;
            this.vy += Math.sin(this.surfaceAngle) * 0.00012 * dt;
            this.thrusting = true;
            trail.emit(this.x, this.y, this.vx, this.vy, "#ffaa44");

            if(this.distanceTo(this.landedPlanet.position()) > this.landedPlanet.size + 120){
                this.state = "idle";
                this.landedPlanet = null;
                this.target = null;
                this.thrusting = false;
                this.takeoffTimer = 0;
                this.takeoffBlastEmitted = false;
            }
        }

        // IDLE WANDER
        if(this.state === "idle"){
            const dx = this.wanderX - this.x;
            const dy = this.wanderY - this.y;
            const dist = Math.hypot(dx, dy);
            if(dist < 30){
                this._pickWander();
            } else {
                const angle = Math.atan2(dy, dx);
                const thrust = 0.00012;
                this.vx += Math.cos(angle) * thrust * dt;
                this.vy += Math.sin(angle) * thrust * dt;
                const spd = Math.hypot(this.vx, this.vy);
                if(spd > 0.18){ this.vx *= 0.18/spd; this.vy *= 0.18/spd; }
            }
            this.thrusting = Math.hypot(this.vx, this.vy) > 0.05;
            if(this.thrusting)
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
        }

        // PHYSICS
        if(this.state === "transfer" || this.state === "takeoff" || this.state === "idle"){
            this.x += this.vx * dt * 0.1;
            this.y += this.vy * dt * 0.1;
            if(Math.hypot(this.vx, this.vy) > 0.01){
                let targetRotation = Math.atan2(this.vy, this.vx) + Math.PI/2;

                if(this.state === "transfer" && this.target){
                    const tp = this.target.position();
                    const dist = Math.hypot(tp.x - this.x, tp.y - this.y);
                    const blendStart = 120;
                    if(dist < blendStart){
                        const surfAngle = Math.atan2(this.y - tp.y, this.x - tp.x);
                        const landingRot = surfAngle + Math.PI/2;
                        const blend = 1 - dist / blendStart;
                        targetRotation = lerpAngle(targetRotation, landingRot, blend);
                    }
                }

                this.rotation = lerpAngle(this.rotation, targetRotation, Math.min(1, 0.005 * dt));
            }
        }

        // SCREEN BOUNDS repulsion (idle only)
        if(this.state === "idle"){
            const repulseZone = 260;
            const repulseStr  = 0.018;
            const left   = this.x;
            const right  = canvas.width  - this.x;
            const top    = this.y;
            const bottom = canvas.height - this.y;
            if(left   < repulseZone) this.vx += repulseStr * dt * Math.pow(1 - left   / repulseZone, 3);
            if(right  < repulseZone) this.vx -= repulseStr * dt * Math.pow(1 - right  / repulseZone, 3);
            if(top    < repulseZone) this.vy += repulseStr * dt * Math.pow(1 - top    / repulseZone, 3);
            if(bottom < repulseZone) this.vy -= repulseStr * dt * Math.pow(1 - bottom / repulseZone, 3);
        }

        // Global speed cap
        const maxSpd = 1.4;
        const spd = Math.hypot(this.vx, this.vy);
        if(spd > maxSpd){ this.vx *= maxSpd/spd; this.vy *= maxSpd/spd; }

        // Hard clamp
        const margin = 10;
        this.x = Math.max(margin, Math.min(canvas.width  - margin, this.x));
        this.y = Math.max(margin, Math.min(canvas.height - margin, this.y));

        const wpad = 260 + 20;
        this.wanderX = Math.max(wpad, Math.min(canvas.width  - wpad, this.wanderX));
        this.wanderY = Math.max(wpad, Math.min(canvas.height - wpad, this.wanderY));

        this.updateHUD();
    }

    land(){
        this.state = "landed";
        this.landedPlanet = this.target;

        const pp = this.landedPlanet.position();
        this.surfaceAngle = Math.atan2(this.y - pp.y, this.x - pp.x);
        this.x = pp.x + Math.cos(this.surfaceAngle) * this.landedPlanet.size;
        this.y = pp.y + Math.sin(this.surfaceAngle) * this.landedPlanet.size;
        this.vx = 0;
        this.vy = 0;

        // Landing dust plume!
        emitLandingDust(this.landedPlanet, this.surfaceAngle);

        this.evaResource = this.landedPlanet.resource;
        const deficit = 100 - this.resources[this.evaResource];
        this.evaRefillRate = deficit / 2000;

        // Spawn a package on the planet
        pkg.spawn(this.landedPlanet, this.surfaceAngle);

        // Deploy astronaut to walk to the package
        astronaut.deploy(this);
    }

    distanceTo(p){ return Math.hypot(this.x - p.x, this.y - p.y); }

    updateHUD(){

    // =============================
    // RESOURCE BARS
    // =============================
    for(let key of ['oxygen','water','food','fuel']){

        const val = Math.round(this.resources[key]);

        const bar   = document.getElementById('bar-' + key);
        const valEl = document.getElementById('val-' + key);
        const rowEl = document.getElementById('row-' + key);

        if(bar)   bar.style.width = val + '%';
        if(valEl) valEl.textContent = val;

        if(rowEl)
            rowEl.classList.toggle('critical', val < 15);

        if(val <= 0 && this.spawned && !gameOver)
            triggerGameOver(key);
    }


    // =============================
    // STATE LABEL
    // =============================
    const stateEl  = document.getElementById('state-label');
    const targetEl = document.getElementById('target-label');

    if(stateEl){
        if(!this.spawned){
            stateEl.textContent = "STANDBY";
        }
        else if(this.state === "loading"){
            const pct = Math.min(
                100,
                Math.floor((this.loadingTimer / this.loadingDuration) * 100)
            );
            const resName = this.loadingResource
                ? this.loadingResource.toUpperCase()
                : "CARGO";
            stateEl.textContent = "LOADING " + resName + " " + pct + "%";
        }
        else{
            stateEl.textContent = this.state.toUpperCase();
        }
    }
    // =============================
    // TARGET LABEL
    // =============================
    if(targetEl){
        targetEl.textContent =
            this.target ? this.target.name.toUpperCase() : "—";
    }
}

    draw(){
        if(!this.spawned) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.scale(0.2, 0.2);

        // Engine glow
        if(this.thrusting){
            const grd = ctx.createRadialGradient(0, 25, 2, 0, 25, 28);
            grd.addColorStop(0, 'rgba(255,180,60,0.9)');
            grd.addColorStop(1, 'rgba(255,80,0,0)');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(0, 25, 28, 0, Math.PI*2);
            ctx.fill();

            // Enhanced flame during takeoff
            if(this.state === "takeoff"){
                const flameLen = 35 + Math.sin(Date.now() * 0.02) * 10;
                const grd2 = ctx.createRadialGradient(0, 30, 3, 0, 30 + flameLen * 0.5, flameLen);
                grd2.addColorStop(0, 'rgba(255,255,200,0.8)');
                grd2.addColorStop(0.3, 'rgba(255,160,40,0.6)');
                grd2.addColorStop(0.6, 'rgba(255,80,10,0.3)');
                grd2.addColorStop(1, 'rgba(255,40,0,0)');
                ctx.fillStyle = grd2;
                ctx.beginPath();
                ctx.arc(0, 30 + flameLen * 0.3, flameLen, 0, Math.PI * 2);
                ctx.fill();

                // Inner white-hot core
                const coreLen = flameLen * 0.4;
                ctx.fillStyle = 'rgba(255,255,240,0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 28, 5, coreLen, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Body
        ctx.fillStyle = "#dde8f0";
        ctx.beginPath();
        if(ctx.roundRect) ctx.roundRect(-10, -28, 20, 44, 4);
        else ctx.rect(-10, -28, 20, 44);
        ctx.fill();

        // Cockpit
        ctx.fillStyle = "#00ccff";
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.ellipse(0, -18, 7, 10, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Wings
        ctx.fillStyle = "#aabbc8";
        ctx.beginPath();
        ctx.moveTo(-10, 5); ctx.lineTo(-26, 18); ctx.lineTo(-10, 14);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(10, 5); ctx.lineTo(26, 18); ctx.lineTo(10, 14);
        ctx.closePath(); ctx.fill();

        // Nozzle
        ctx.fillStyle = "#778899";
        ctx.fillRect(-7, 14, 14, 8);

        ctx.restore();
    }
}

const ship = new Ship();

// =============================
// ASTRONAUT
// =============================
class Astronaut {
    constructor(){
        this.state = "idle";
        this.planet = null;
        this.surfaceAngle = 0;
        this.targetAngle = 0;
        this.carrying = false;
        this.shipAngle = 0; // remember where the ship is
    }

    deploy(s){
        this.planet = s.landedPlanet;
        this.surfaceAngle = s.surfaceAngle + 0.08; // start just beside the ship
        this.shipAngle = s.surfaceAngle;

        // Walk to the package location
        if(pkg.active){
            this.targetAngle = pkg.surfaceAngle;
        } else {
            this.targetAngle = this.surfaceAngle + 0.6;
        }

        this.state = "walking_out";
        this.carrying = false;
        s.state = "eva";
    }

    update(dt){
        if(this.state === "idle") return;

        // Calculate angle difference properly
            const diff = angleDiff(this.surfaceAngle, this.targetAngle);

            if (Math.abs(diff) < 0.015) {

                if (this.state === "walking_out") {

                    this.carrying = true;
                    pkg.dismiss();

                    this.targetAngle = this.shipAngle;
                    this.state = "walking_back";

                } else if (this.state === "walking_back") {

                    this.carrying = false;
                    this.state = "idle";

                    ship.loadingResource = this.planet.resource;
                    ship.loadingTimer = 0;
                    ship.state = "loading";
                }

            } else {

                // Slower walking speed
                const step = angleDiff(this.surfaceAngle, this.targetAngle);
                const walkSpeed = 0.02;      // slowed
                const move = Math.sign(step) * Math.min(Math.abs(step), walkSpeed);

                this.surfaceAngle += move * dt * 0.035; // slowed
            }
        }

    

    draw(t){
        if(this.state === "idle") return;

        const p = this.planet.position();
        const r = this.planet.size + 4;

        const walking = Math.abs(angleDiff(this.surfaceAngle, this.targetAngle)) > 0.02;
        const bob  = walking ? Math.sin(t * 0.015) * 1.2 : 0;
        const lean = walking ? Math.sin(t * 0.008) * 0.07 : 0;

        const x = p.x + Math.cos(this.surfaceAngle) * r;
        const y = p.y + Math.sin(this.surfaceAngle) * r;
        const bobX = -Math.sin(this.surfaceAngle) * bob;
        const bobY =  Math.cos(this.surfaceAngle) * bob;

        ctx.save();
        ctx.translate(x + bobX, y + bobY);
        ctx.rotate(this.surfaceAngle + Math.PI/2 + lean);
        ctx.scale(0.2, 0.2);

        // Helmet
        ctx.fillStyle = "rgba(200,230,255,0.9)";
        ctx.beginPath();
        ctx.arc(0, -14, 9, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "rgba(0,180,255,0.5)";
        ctx.beginPath();
        ctx.arc(0, -14, 6, 0, Math.PI*2);
        ctx.fill();

        // Suit body
        ctx.fillStyle = "#dde8f0";
        ctx.fillRect(-6, -5, 12, 16);

        // Arms
        if(this.carrying){
            // Arms reaching up to hold the crate
            ctx.fillStyle = "#ccd8e4";
            ctx.fillRect(-10, -22, 4, 14);
            ctx.fillRect( 6, -22, 4, 14);
        } else {
            // Swinging arms
            const armSwing = walking ? Math.sin(t * 0.015) * 4 : 0;
            ctx.fillStyle = "#ccd8e4";
            ctx.fillRect(-10, -3 + armSwing, 4, 10);
            ctx.fillRect( 6, -3 - armSwing, 4, 10);
        }

        // Legs with step animation
        if(walking){
            const step = Math.sin(t * 0.015);
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8 + step*3);
            ctx.fillRect( 1, 11, 4, 8 - step*3);

            // Tiny dust puffs at feet
            if(Math.random() > 0.7){
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = "#aaa";
                ctx.beginPath();
                ctx.arc(step > 0 ? -3 : 3, 20, 2 + Math.random()*2, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        } else {
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8);
            ctx.fillRect( 1, 11, 4, 8);
        }

        // Resource crate above head
        if(this.carrying){
            ctx.fillStyle = "#cc8800";
            ctx.strokeStyle = "#aa6600";
            ctx.lineWidth = 1;
            if(ctx.roundRect){
                ctx.beginPath();
                ctx.roundRect(-7, -32, 14, 10, 2);
                ctx.fill();
                ctx.stroke();
            } else {
                ctx.fillRect(-7, -32, 14, 10);
                ctx.strokeRect(-7, -32, 14, 10);
            }
            ctx.fillStyle = "rgba(255,200,0,0.5)";
            ctx.fillRect(-5, -30, 10, 6);

            // Cross straps on crate
            ctx.strokeStyle = "#886600";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(-7, -32); ctx.lineTo(7, -22);
            ctx.moveTo(7, -32); ctx.lineTo(-7, -22);
            ctx.stroke();
        }

        ctx.restore();
    }
}

const astronaut = new Astronaut();

// =============================
// AI
// =============================
function chooseNext(){
    if(!ship.spawned || ship.state !== "idle") return;

    let best = null, bestScore = 0;

    for(let p of planets){
        const need = 100 - ship.resources[p.resource];

        if(p.resource === "oxygen" && ship.resources.oxygen < 15){
            best = p; break;
        }

        let weight = 1;
        if(p.resource === "oxygen") weight = 3;
        if(p.resource === "fuel")   weight = 2.5;
        if(p.resource === "water")  weight = 2;

        const dist = ship.distanceTo(p.position());
        const distPenalty = Math.max(0.3, 1 - dist / 1500);
        const score = need * weight * distPenalty;
        if(score > bestScore){ bestScore = score; best = p; }
    }

    if(best && (bestScore > 15 || (best.resource === "oxygen" && ship.resources.oxygen < 15))){
        ship.target = best;
        ship.state = "transfer";
    }
}

// =============================
// GAME OVER
// =============================
let gameOver = false;
const RESOURCE_NAMES = { oxygen:'OXYGEN', water:'WATER', food:'FOOD', fuel:'FUEL' };

function triggerGameOver(resource){
    gameOver = true;
    document.getElementById('gameover-reason').textContent =
        RESOURCE_NAMES[resource] + ' DEPLETED — CREW LOST';
    document.getElementById('gameover').classList.add('active');
}

// =============================
// MAIN LOOP
// =============================
let last = 0;
function loop(t){
    if(gameOver) return;
    const dt = Math.min(t - last, 50);
    last = t;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Stars — screen-fixed, no camera transform
    drawStars(t);

    // World — apply camera
    if(camera.follow && ship.spawned){
    camera.panX = canvas.width / 2 - ship.x * camera.zoom;
    camera.panY = canvas.height / 2 - ship.y * camera.zoom;
}

    ctx.save();
    applyCamera();

    drawSun(t);

    for(let p of planets){ p.update(dt); p.draw(t); }

    trail.update(dt);
    trail.draw();

    updateSpawnParticles(dt);
    drawSpawnParticles();

    updateDustParticles(dt);
    drawDustParticles();

    ship.update(dt);
    astronaut.update(dt);
    pkg.update(dt);
    chooseNext();

    // Draw package before ship/astronaut so it's behind them
    pkg.draw(t);
    ship.draw();
    astronaut.draw(t);

    ctx.restore();

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
