<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Orbital Surface Simulation</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; }
body { margin:0; overflow:hidden; background:#000; font-family:'Share Tech Mono', monospace; cursor:crosshair; }
canvas { display:block; }

#hud {
    position:fixed;
    top:20px;
    left:20px;
    width:220px;
    pointer-events:none;
    z-index:10;
}
#hud h2 {
    font-family:'Orbitron', sans-serif;
    font-size:10px;
    letter-spacing:4px;
    color:#aaa;
    margin:0 0 12px 0;
    text-transform:uppercase;
}
.res-row { margin-bottom:10px; }
.res-label {
    font-size:10px;
    letter-spacing:2px;
    color:#888;
    display:flex;
    justify-content:space-between;
    margin-bottom:3px;
}
.res-label span:last-child { color:#ccc; }
.res-track {
    width:100%;
    height:6px;
    background:rgba(255,255,255,0.07);
    border-radius:3px;
    overflow:hidden;
    position:relative;
}
.res-fill {
    height:100%;
    border-radius:3px;
    transition:width 0.3s ease;
    position:relative;
}
.res-fill::after {
    content:'';
    position:absolute;
    right:0; top:0; bottom:0;
    width:3px;
    background:rgba(255,255,255,0.6);
    border-radius:3px;
}
.critical .res-fill { animation: pulse-bar 0.5s ease-in-out infinite alternate; }
@keyframes pulse-bar {
    from { opacity:1; }
    to { opacity:0.4; }
}
.status-row {
    margin-top:8px;
    font-size:9px;
    letter-spacing:2px;
    color:#555;
    text-transform:uppercase;
}
.status-row .status-val { color:#0af; }
#zoom-hint {
    position:fixed;
    bottom:20px;
    right:20px;
    font-size:9px;
    letter-spacing:2px;
    color:#2a2a2a;
    pointer-events:none;
    z-index:10;
}
#gameover {
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.75);
    z-index:100;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    text-align:center;
}
#gameover.active { display:flex; }
#gameover h1 {
    font-family:'Orbitron', sans-serif;
    font-size:28px;
    letter-spacing:6px;
    color:#ff3344;
    margin:0 0 12px 0;
    text-transform:uppercase;
}
#gameover p {
    font-size:11px;
    letter-spacing:3px;
    color:#777;
    margin:0 0 28px 0;
    text-transform:uppercase;
}
#gameover button {
    font-family:'Share Tech Mono', monospace;
    font-size:11px;
    letter-spacing:3px;
    text-transform:uppercase;
    background:none;
    border:1px solid #0af;
    color:#0af;
    padding:10px 28px;
    cursor:pointer;
}
#gameover button:hover { background:rgba(0,170,255,0.1); }
</style>
</head>
<body>
<canvas id="sim"></canvas>

<div id="hud">
    <h2>Ship Status</h2>
    <div class="res-row" id="row-oxygen">
        <div class="res-label"><span>OXYGEN</span><span id="val-oxygen">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-oxygen" style="background:#00bbff;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-water">
        <div class="res-label"><span>WATER</span><span id="val-water">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-water" style="background:#3366ff;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-food">
        <div class="res-label"><span>FOOD</span><span id="val-food">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-food" style="background:#44dd77;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-fuel">
        <div class="res-label"><span>FUEL</span><span id="val-fuel">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-fuel" style="background:#ffaa00;width:100%"></div></div>
    </div>
    <div class="status-row">STATE: <span class="status-val" id="state-label">STANDBY</span></div>
    <div class="status-row">TARGET: <span class="status-val" id="target-label">—</span></div>
</div>

<div id="zoom-hint">SCROLL TO ZOOM &nbsp;·&nbsp; DRAG TO PAN</div>

<div id="gameover">
    <h1>Mission Failed</h1>
    <p id="gameover-reason">Critical resource depleted</p>
    <button onclick="location.reload()">Restart Mission</button>
</div>

<script>
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

// =============================
// CAMERA
// =============================
const camera = { zoom: 1, panX: 0, panY: 0 };

canvas.addEventListener("wheel", e => {
    e.preventDefault();
    const f = e.deltaY < 0 ? 1.12 : 0.89;
    const mx = e.clientX - canvas.width / 2;
    const my = e.clientY - canvas.height / 2;
    // zoom toward cursor
    camera.panX = camera.panX * f + mx * (1 - f);
    camera.panY = camera.panY * f + my * (1 - f);
    camera.zoom = Math.max(0.2, Math.min(14, camera.zoom * f));
}, { passive: false });

let dragging = false, dragStart = {x:0,y:0}, panStart = {x:0,y:0};
canvas.addEventListener("mousedown", e => {
    dragging = true;
    dragStart = { x: e.clientX, y: e.clientY };
    panStart  = { x: camera.panX, y: camera.panY };
});
canvas.addEventListener("mousemove", e => {
    if(!dragging) return;
    camera.panX = panStart.x + (e.clientX - dragStart.x);
    camera.panY = panStart.y + (e.clientY - dragStart.y);
});
window.addEventListener("mouseup", () => dragging = false);

function applyCamera(){
    ctx.translate(canvas.width/2 + camera.panX, canvas.height/2 + camera.panY);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-canvas.width/2, -canvas.height/2);
}

// =============================
// RESIZE + STARS
// =============================
let stars = [];
function buildStars(){
    stars = [];
    for(let i = 0; i < 350; i++){
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: Math.random() * 1.3 + 0.2,
            a: Math.random() * 0.7 + 0.3,
            tw: Math.random() * 3 + 1
        });
    }
}
function resize(){
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    buildStars();
}
window.addEventListener("resize", resize);
resize();

function center(){ return { x: canvas.width/2, y: canvas.height/2 }; }

function drawStars(t){
    for(let s of stars){
        const twinkle = 0.6 + 0.4 * Math.sin(t / 1000 * s.tw);
        ctx.globalAlpha = s.a * twinkle;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// =============================
// COLOR UTILS
// =============================
function shiftColor(hex, amt){
    let r, g, b;
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    if(m){ r=parseInt(m[1],16); g=parseInt(m[2],16); b=parseInt(m[3],16); }
    else {
        const tmp=document.createElement('canvas'); tmp.width=tmp.height=1;
        const tc=tmp.getContext('2d'); tc.fillStyle=hex; tc.fillRect(0,0,1,1);
        const d=tc.getImageData(0,0,1,1).data; r=d[0];g=d[1];b=d[2];
    }
    r=Math.min(255,Math.max(0,Math.round(r+amt*255)));
    g=Math.min(255,Math.max(0,Math.round(g+amt*255)));
    b=Math.min(255,Math.max(0,Math.round(b+amt*255)));
    return `rgb(${r},${g},${b})`;
}
const lighten = (h, a) => shiftColor(h,  a);
const darken  = (h, a) => shiftColor(h, -a);

// =============================
// SUN
// =============================
function drawSun(t){
    const c = center();
    const pulse = 1 + 0.02 * Math.sin(t / 600);

    for(let i = 3; i > 0; i--){
        const grad = ctx.createRadialGradient(c.x, c.y, 24, c.x, c.y, 40*i*pulse);
        grad.addColorStop(0, 'rgba(255,200,50,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 40*i*pulse, 0, Math.PI*2);
        ctx.fill();
    }

    const sunGrad = ctx.createRadialGradient(c.x-8, c.y-8, 4, c.x, c.y, 28*pulse);
    sunGrad.addColorStop(0, '#fff8c0');
    sunGrad.addColorStop(0.4, '#ffcc00');
    sunGrad.addColorStop(1, '#ff6600');
    ctx.fillStyle = sunGrad;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 28*pulse, 0, Math.PI*2);
    ctx.fill();
}

// =============================
// PLANETS
// =============================
function hexToRgba(hex, a){
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    return m ? `rgba(${parseInt(m[1],16)},${parseInt(m[2],16)},${parseInt(m[3],16)},${a})` : hex;
}

class Planet {
    constructor(name, orbitFactor, size, color, resource, glowColor){
        this.name = name;
        this.orbitFactor = orbitFactor;
        this.size = size;
        this.color = color;
        this.glowColor = glowColor || color;
        this.glowRGBA = hexToRgba(this.glowColor, 0.2);
        this.resource = resource;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 0.00005 + Math.random() * 0.00003;
    }

    orbitRadius(){
        return Math.min(canvas.width, canvas.height) / 2 * this.orbitFactor;
    }

    update(dt){ this.angle += this.speed * dt; }

    position(){
        const c = center();
        const r = this.orbitRadius();
        return { x: c.x + Math.cos(this.angle)*r, y: c.y + Math.sin(this.angle)*r };
    }

    draw(t){
        const p  = this.position();
        const c  = center();
        const r  = this.orbitRadius();

        // Orbit ring — thin, independent of zoom
        ctx.beginPath();
        ctx.arc(c.x, c.y, r, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.04)";
        ctx.lineWidth = 1 / camera.zoom;
        ctx.stroke();

        // Atmosphere glow
        const pulse = 1 + 0.04 * Math.sin(t / 800);
        const grad = ctx.createRadialGradient(p.x, p.y, this.size*0.5, p.x, p.y, this.size*3*pulse);
        grad.addColorStop(0, this.glowRGBA);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.beginPath();
        ctx.arc(p.x, p.y, this.size*3*pulse, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Planet body
        const bg = ctx.createRadialGradient(p.x - this.size*0.3, p.y - this.size*0.3, this.size*0.1, p.x, p.y, this.size);
        bg.addColorStop(0, lighten(this.color, 0.4));
        bg.addColorStop(1, darken(this.color, 0.4));
        ctx.fillStyle = bg;
        ctx.beginPath();
        ctx.arc(p.x, p.y, this.size, 0, Math.PI*2);
        ctx.fill();

        // Label — constant screen size regardless of zoom
        ctx.save();
        ctx.font = `${9 / camera.zoom}px 'Share Tech Mono'`;
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.textAlign = "center";
        ctx.fillText(this.name.toUpperCase(), p.x, p.y + this.size + 14 / camera.zoom);
        ctx.restore();
    }
}

// Spread orbits out significantly more than before
const planets = [
    new Planet("Oxygen", 0.28, 14, "#00aaff", "oxygen", "#00aaff"),
    new Planet("Food",   0.46, 15, "#44cc66", "food",   "#44cc66"),
    new Planet("Water",  0.67, 13, "#2255dd", "water",  "#2255dd"),
    new Planet("Fuel",   0.90, 17, "#dd8800", "fuel",   "#dd8800"),
];

// =============================
// THRUST TRAIL
// =============================
class Trail {
    constructor(){ this.particles = []; }

    emit(x, y, vx, vy, color){
        for(let i = 0; i < 3; i++){
            this.particles.push({
                x, y,
                vx: vx * -0.08 + (Math.random()-0.5) * 0.8,
                vy: vy * -0.08 + (Math.random()-0.5) * 0.8,
                life: 1,
                decay: 0.025 + Math.random() * 0.02,
                size: 0.6 + Math.random() * 0.8,
                color
            });
        }
    }

    update(dt){
        for(let p of this.particles){
            p.x += p.vx * dt * 0.1;
            p.y += p.vy * dt * 0.1;
            p.life -= p.decay * dt * 0.1;
        }
        this.particles = this.particles.filter(p => p.life > 0);
    }

    draw(){
        for(let p of this.particles){
            ctx.globalAlpha = p.life * 0.7;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

const trail = new Trail();

// =============================
// SPAWN BURST
// =============================
const spawnParticles = [];

function triggerSpawn(x, y){
    const colors = ['#ffffff','#00ccff','#88eeff','#ffcc44','#ff8833','#aaffcc'];
    for(let i = 0; i < 90; i++){
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 3.5;
        spawnParticles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            decay: 0.003 + Math.random() * 0.005,
            size: 0.8 + Math.random() * 2.5,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
}

function updateSpawnParticles(dt){
    for(let p of spawnParticles) {
        p.x += p.vx * dt * 0.1;
        p.y += p.vy * dt * 0.1;
        p.vx *= 0.97;
        p.vy *= 0.97;
        p.life -= p.decay * dt * 0.1;
    }
    for(let i = spawnParticles.length - 1; i >= 0; i--)
        if(spawnParticles[i].life <= 0) spawnParticles.splice(i, 1);
}

function drawSpawnParticles(){
    for(let p of spawnParticles){
        if(p.life <= 0) continue;
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// =============================
// ANGLE UTILS
// =============================
function lerpAngle(current, target, t){
    let diff = target - current;
    while(diff >  Math.PI) diff -= Math.PI * 2;
    while(diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * t;
}

// =============================
// SHIP
// =============================
class Ship {
    constructor(){
        const c = center();
        this.x = c.x;
        this.y = c.y - 200;
        this.vx = 0;
        this.vy = 0;
        this.rotation = 0;
        this.thrusting = false;

        this.state = "idle";
        this.target = null;
        this.landedPlanet = null;
        this.surfaceAngle = 0;

        this.resources = { oxygen:100, water:100, food:100, fuel:100 };
        this.evaRefillRate = 0;
        this.evaResource = null;

        // Spawn
        this.spawned = false;
        this.spawnTimer = 0;
        this.SPAWN_DELAY = 1200;

        // Idle wander
        this.wanderX = 0;
        this.wanderY = 0;
        this._pickWander();
    }

    _pickWander(){
        const pad = 280;
        this.wanderX = pad + Math.random() * (canvas.width  - pad*2);
        this.wanderY = pad + Math.random() * (canvas.height - pad*2);
    }

    update(dt){
        // Spawn countdown — ship waits before appearing
        if(!this.spawned){
            this.spawnTimer += dt;
            if(this.spawnTimer >= this.SPAWN_DELAY){
                this.spawned = true;
                triggerSpawn(this.x, this.y);
            }
            return;
        }

        // RESOURCE DRAIN
        if(this.state === "eva")
            this.resources.oxygen -= 0.002 * dt;

        this.resources.water -= 0.001 * dt;
        this.resources.food  -= 0.0006 * dt;

        if(this.state === "transfer" || this.state === "takeoff")
            this.resources.fuel -= 0.0015 * dt;

        // Resource refill happens on package delivery (see Astronaut.update)

        for(let r in this.resources)
            this.resources[r] = Math.max(0, this.resources[r]);

        // TRANSFER — slow thrust, always tracking moving target
        if(this.state === "transfer"){
            const tp = this.target.position();
            const dx = tp.x - this.x;
            const dy = tp.y - this.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);

            // Desired speed increases with distance
            const maxSpeed = 1.4;
            const arriveRadius = 120;
            let desiredSpeed = dist < arriveRadius ? maxSpeed * (dist / arriveRadius) : maxSpeed;

            // Desired velocity
            const desiredVX = Math.cos(angle) * desiredSpeed;
            const desiredVY = Math.sin(angle) * desiredSpeed;

            // Steering force
            const steerStrength = 0.08;
            this.vx += (desiredVX - this.vx) * steerStrength;
            this.vy += (desiredVY - this.vy) * steerStrength;

            const landDist = this.target.size + Ship.LANDING_OFFSET + 2;
            this.thrusting = dist > landDist + 4;
            if(this.thrusting){
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
            }

            // Land when close enough
            if(dist <= landDist){
                this.land();
            }
        }



        // LANDED / EVA — stick to planet surface, offset so nozzle base touches
        if(this.state === "landed" || this.state === "eva"){
            const pp = this.landedPlanet.position();
            const r = this.landedPlanet.size + Ship.LANDING_OFFSET;
            this.x = pp.x + Math.cos(this.surfaceAngle) * r;
            this.y = pp.y + Math.sin(this.surfaceAngle) * r;
            this.rotation = this.surfaceAngle + Math.PI/2;
            this.thrusting = false;
        }

        // TAKEOFF
        if(this.state === "takeoff"){
            this.vx += Math.cos(this.surfaceAngle) * 0.00012 * dt;
            this.vy += Math.sin(this.surfaceAngle) * 0.00012 * dt;
            this.thrusting = true;
            trail.emit(this.x, this.y, this.vx, this.vy, "#ffaa44");

            if(this.distanceTo(this.landedPlanet.position()) > this.landedPlanet.size + 120){
                this.state = "idle";
                this.landedPlanet = null;
                this.target = null;
                this.thrusting = false;
            }
        }

        // IDLE WANDER — drift toward a roaming waypoint
        if(this.state === "idle"){
            const dx = this.wanderX - this.x;
            const dy = this.wanderY - this.y;
            const dist = Math.hypot(dx, dy);
            if(dist < 30){
                this._pickWander();
            } else {
                const angle = Math.atan2(dy, dx);
                const thrust = 0.00012;
                this.vx += Math.cos(angle) * thrust * dt;
                this.vy += Math.sin(angle) * thrust * dt;
                // gentle speed cap so it doesn't build up
                const spd = Math.hypot(this.vx, this.vy);
                if(spd > 0.18){ this.vx *= 0.18/spd; this.vy *= 0.18/spd; }
            }
            this.thrusting = Math.hypot(this.vx, this.vy) > 0.05;
            if(this.thrusting)
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
        }

        // PHYSICS
        if(this.state === "transfer" || this.state === "takeoff" || this.state === "idle"){
            this.x += this.vx * dt * 0.1;
            this.y += this.vy * dt * 0.1;
            if(Math.hypot(this.vx, this.vy) > 0.01){
                let targetRotation = Math.atan2(this.vy, this.vx) + Math.PI/2;

                // During transfer, blend toward landing orientation as we approach
                if(this.state === "transfer" && this.target){
                    const tp = this.target.position();
                    const dist = Math.hypot(tp.x - this.x, tp.y - this.y);
                    const blendStart = 120;
                    if(dist < blendStart){
                        const surfAngle = Math.atan2(this.y - tp.y, this.x - tp.x);
                        const landingRot = surfAngle + Math.PI/2;
                        const blend = 1 - dist / blendStart;
                        targetRotation = lerpAngle(targetRotation, landingRot, blend);
                    }
                }

                // Smooth rotation — no snap turning
                this.rotation = lerpAngle(this.rotation, targetRotation, Math.min(1, 0.005 * dt));
            }
        }

        /* CHANGE #2: repulsion only during idle */
        // SCREEN BOUNDS — smooth repulsion starts 260px from each edge, cubic falloff
        if(this.state === "idle"){
            const repulseZone = 260;
            const repulseStr  = 0.018;
            const left   = this.x;
            const right  = canvas.width  - this.x;
            const top    = this.y;
            const bottom = canvas.height - this.y;
            if(left   < repulseZone) this.vx += repulseStr * dt * Math.pow(1 - left   / repulseZone, 3);
            if(right  < repulseZone) this.vx -= repulseStr * dt * Math.pow(1 - right  / repulseZone, 3);
            if(top    < repulseZone) this.vy += repulseStr * dt * Math.pow(1 - top    / repulseZone, 3);
            if(bottom < repulseZone) this.vy -= repulseStr * dt * Math.pow(1 - bottom / repulseZone, 3);
        }

        // Global speed cap — matches transfer maxSpeed so the target is reachable
        const maxSpd = 1.4;
        const spd = Math.hypot(this.vx, this.vy);
        if(spd > maxSpd){ this.vx *= maxSpd/spd; this.vy *= maxSpd/spd; }

        // Hard clamp — absolute last resort, should never visibly trigger
        const margin = 10;
        this.x = Math.max(margin, Math.min(canvas.width  - margin, this.x));
        this.y = Math.max(margin, Math.min(canvas.height - margin, this.y));

        const wpad = 260 + 20;
        this.wanderX = Math.max(wpad, Math.min(canvas.width  - wpad, this.wanderX));
        this.wanderY = Math.max(wpad, Math.min(canvas.height - wpad, this.wanderY));

        this.updateHUD();
    }

    // Half-height of ship in world units: nozzle tip is at local y=+22, scale=0.2 → 4.4px from center
    // We offset the ship center by this so the nozzle base sits flush on the planet surface.
    static get LANDING_OFFSET(){ return 4.4; }

    land(){
        this.state = "landed";
        this.landedPlanet = this.target;

        const pp = this.landedPlanet.position();
        this.surfaceAngle = Math.atan2(this.y - pp.y, this.x - pp.x);
        const r = this.landedPlanet.size + Ship.LANDING_OFFSET;
        this.x = pp.x + Math.cos(this.surfaceAngle) * r;
        this.y = pp.y + Math.sin(this.surfaceAngle) * r;
        this.vx = 0;
        this.vy = 0;

        this.evaResource = this.landedPlanet.resource;

        astronaut.deploy(this);
    }

    distanceTo(p){ return Math.hypot(this.x - p.x, this.y - p.y); }

    updateHUD(){
        for(let key of ['oxygen','water','food','fuel']){
            const val = Math.round(this.resources[key]);
            const bar   = document.getElementById('bar-'+key);
            const valEl = document.getElementById('val-'+key);
            const rowEl = document.getElementById('row-'+key);
            if(bar)   bar.style.width = val + '%';
            if(valEl) valEl.textContent = val;
            if(rowEl) rowEl.classList.toggle('critical', val < 15);
            if(val <= 0 && this.spawned && !gameOver) triggerGameOver(key);
        }
        const stateEl  = document.getElementById('state-label');
        const targetEl = document.getElementById('target-label');
        if(stateEl)  stateEl.textContent  = this.spawned ? this.state.toUpperCase() : 'STANDBY';
        if(targetEl) targetEl.textContent = this.target ? this.target.name.toUpperCase() : '—';
    }

    draw(){
        if(!this.spawned) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.scale(0.2, 0.2);

        // Engine glow
        if(this.thrusting){
            const grd = ctx.createRadialGradient(0, 25, 2, 0, 25, 28);
            grd.addColorStop(0, 'rgba(255,180,60,0.9)');
            grd.addColorStop(1, 'rgba(255,80,0,0)');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(0, 25, 28, 0, Math.PI*2);
            ctx.fill();
        }

        // Body
        ctx.fillStyle = "#dde8f0";
        ctx.beginPath();
        if(ctx.roundRect) ctx.roundRect(-10, -28, 20, 44, 4);
        else ctx.rect(-10, -28, 20, 44);
        ctx.fill();

        // Cockpit
        ctx.fillStyle = "#00ccff";
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.ellipse(0, -18, 7, 10, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Wings
        ctx.fillStyle = "#aabbc8";
        ctx.beginPath();
        ctx.moveTo(-10, 5); ctx.lineTo(-26, 18); ctx.lineTo(-10, 14);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(10, 5); ctx.lineTo(26, 18); ctx.lineTo(10, 14);
        ctx.closePath(); ctx.fill();

        // Nozzle
        ctx.fillStyle = "#778899";
        ctx.fillRect(-7, 14, 14, 8);

        ctx.restore();
    }
}

const ship = new Ship();

// =============================
// PACKAGE
// =============================
class Package {
    constructor(){
        this.planet = null;
        this.surfaceAngle = 0;
        this.visible = false;
        this.collected = false;
    }

    spawn(planet, atAngle){
        this.planet = planet;
        this.surfaceAngle = atAngle;
        this.visible = true;
        this.collected = false;
    }

    hide(){
        this.visible = false;
        this.collected = false;
        this.planet = null;
    }

    position(){
        if(!this.planet) return {x:0, y:0};
        const pp = this.planet.position();
        const r = this.planet.size + 2;
        return {
            x: pp.x + Math.cos(this.surfaceAngle) * r,
            y: pp.y + Math.sin(this.surfaceAngle) * r
        };
    }

    draw(t){
        if(!this.visible || this.collected) return;
        const pos = this.position();

        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(this.surfaceAngle + Math.PI/2);
        ctx.scale(0.2, 0.2);

        // Pulsing glow
        const pulse = 0.5 + 0.5 * Math.sin(t * 0.005);
        ctx.globalAlpha = 0.3 + 0.2 * pulse;
        ctx.fillStyle = "#ffcc44";
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Crate body
        ctx.fillStyle = "#cc8800";
        ctx.fillRect(-8, -8, 16, 16);
        // Crate highlight
        ctx.fillStyle = "rgba(255,200,0,0.5)";
        ctx.fillRect(-6, -6, 12, 6);
        // Crate straps
        ctx.strokeStyle = "#996600";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, -8); ctx.lineTo(0, 8);
        ctx.moveTo(-8, 0); ctx.lineTo(8, 0);
        ctx.stroke();

        ctx.restore();
    }
}

const pkg = new Package();

// =============================
// ASTRONAUT
// =============================
class Astronaut {
    constructor(){
        this.state = "idle";
        this.planet = null;
        this.surfaceAngle = 0;
        this.targetAngle = 0;
        this.shipAngle = 0;   // angle where ship is parked
        this.carrying = false;
    }

    deploy(s){
        this.planet = s.landedPlanet;
        this.shipAngle = s.surfaceAngle;
        this.surfaceAngle = s.surfaceAngle + 0.1;

        // Spawn package at a fixed offset from the ship (opposite direction)
        const pkgAngle = s.surfaceAngle + 0.7;
        pkg.spawn(this.planet, pkgAngle);

        this.targetAngle = pkgAngle;   // walk toward package
        this.state = "walking_out";
        this.carrying = false;
        s.state = "eva";
    }

    update(dt){
        if(this.state === "idle") return;

        const arrived = Math.abs(this.surfaceAngle - this.targetAngle) < 0.015;

        if(arrived){
            if(this.state === "walking_out"){
                // Pick up the package
                this.carrying = true;
                pkg.collected = true;
                // Walk back to ship
                this.targetAngle = this.shipAngle + 0.1;
                this.state = "walking_back";
            } else if(this.state === "walking_back"){
                // Delivered — fully refill the resource and take off
                this.carrying = false;
                pkg.hide();
                this.state = "idle";
                if(ship.evaResource)
                    ship.resources[ship.evaResource] = 100;
                ship.evaResource = null;
                ship.state = "takeoff";
            }
        } else {
            this.surfaceAngle += (this.targetAngle - this.surfaceAngle) * 0.05;
        }
    }

    draw(t){
        if(this.state === "idle") return;

        const p = this.planet.position();
        const r = this.planet.size + 4;

        const walking = Math.abs(this.surfaceAngle - this.targetAngle) > 0.02;
        const bob  = walking ? Math.sin(t * 0.015) * 1.2 : 0;
        const lean = walking ? Math.sin(t * 0.008) * 0.07 : 0;

        const x = p.x + Math.cos(this.surfaceAngle) * r;
        const y = p.y + Math.sin(this.surfaceAngle) * r;
        const bobX = -Math.sin(this.surfaceAngle) * bob;
        const bobY =  Math.cos(this.surfaceAngle) * bob;

        ctx.save();
        ctx.translate(x + bobX, y + bobY);
        ctx.rotate(this.surfaceAngle + Math.PI/2 + lean);
        ctx.scale(0.2, 0.2);

        // Helmet
        ctx.fillStyle = "rgba(200,230,255,0.9)";
        ctx.beginPath();
        ctx.arc(0, -14, 9, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "rgba(0,180,255,0.5)";
        ctx.beginPath();
        ctx.arc(0, -14, 6, 0, Math.PI*2);
        ctx.fill();

        // Suit body
        ctx.fillStyle = "#dde8f0";
        ctx.fillRect(-6, -5, 12, 16);

        // Legs with step animation
        if(walking){
            const step = Math.sin(t * 0.015);
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8 + step*3);
            ctx.fillRect( 1, 11, 4, 8 - step*3);
        } else {
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8);
            ctx.fillRect( 1, 11, 4, 8);
        }

        // Carried package (above head)
        if(this.carrying){
            ctx.fillStyle = "#cc8800";
            ctx.fillRect(-7, -28, 14, 12);
            ctx.fillStyle = "rgba(255,200,0,0.5)";
            ctx.fillRect(-5, -26, 10, 6);
            ctx.strokeStyle = "#996600";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, -28); ctx.lineTo(0, -16);
            ctx.moveTo(-7, -22); ctx.lineTo(7, -22);
            ctx.stroke();
        }

        ctx.restore();
    }
}

const astronaut = new Astronaut();

// =============================
// AI
// =============================
function chooseNext(){
    if(!ship.spawned || ship.state !== "idle") return;

    let best = null, bestScore = 0;

    for(let p of planets){
        const need = 100 - ship.resources[p.resource];
        // Don't go to a planet if we don't need the resource meaningfully
        if(need < 10) continue;

        if(p.resource === "oxygen" && ship.resources.oxygen < 15){
            best = p; break;
        }

        let weight = 1;
        if(p.resource === "oxygen") weight = 3;
        if(p.resource === "fuel")   weight = 2.5;
        if(p.resource === "water")  weight = 2;

        const dist = ship.distanceTo(p.position());
        const distPenalty = Math.max(0.3, 1 - dist / 1500);
        const score = need * weight * distPenalty;
        if(score > bestScore){ bestScore = score; best = p; }
    }

    if(best && (bestScore > 15 || (best.resource === "oxygen" && ship.resources.oxygen < 15))){
        ship.target = best;
        ship.state = "transfer";
    }
}

// =============================
// GAME OVER
// =============================
let gameOver = false;
const RESOURCE_NAMES = { oxygen:'OXYGEN', water:'WATER', food:'FOOD', fuel:'FUEL' };

function triggerGameOver(resource){
    gameOver = true;
    document.getElementById('gameover-reason').textContent =
        RESOURCE_NAMES[resource] + ' DEPLETED — CREW LOST';
    document.getElementById('gameover').classList.add('active');
}

// =============================
// MAIN LOOP
// =============================
let last = 0;
function loop(t){
    if(gameOver) return;
    const dt = Math.min(t - last, 50);
    last = t;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Stars — screen-fixed, no camera transform
    drawStars(t);

    // World — apply camera
    ctx.save();
    applyCamera();

    drawSun(t);

    for(let p of planets){ p.update(dt); p.draw(t); }

    trail.update(dt);
    trail.draw();

    updateSpawnParticles(dt);
    drawSpawnParticles();

    ship.update(dt);
    astronaut.update(dt);
    chooseNext();

    pkg.draw(t);
    ship.draw();
    astronaut.draw(t);

    ctx.restore();

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
