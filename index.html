<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Orbital Surface Simulation</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; }
body { margin:0; overflow:hidden; background:#000; font-family:'Share Tech Mono', monospace; cursor:crosshair; }
canvas { display:block; }

#hud {
    position:fixed;
    top:20px;
    left:20px;
    width:220px;
    pointer-events:none;
    z-index:10;
}
#hud h2 {
    font-family:'Orbitron', sans-serif;
    font-size:10px;
    letter-spacing:4px;
    color:#aaa;
    margin:0 0 12px 0;
    text-transform:uppercase;
}
.res-row { margin-bottom:10px; }
.res-label {
    font-size:10px;
    letter-spacing:2px;
    color:#888;
    display:flex;
    justify-content:space-between;
    margin-bottom:3px;
}
.res-label span:last-child { color:#ccc; }
.res-track {
    width:100%;
    height:6px;
    background:rgba(255,255,255,0.07);
    border-radius:3px;
    overflow:hidden;
    position:relative;
}
.res-fill {
    height:100%;
    border-radius:3px;
    transition:width 0.3s ease;
    position:relative;
}
.res-fill::after {
    content:'';
    position:absolute;
    right:0; top:0; bottom:0;
    width:3px;
    background:rgba(255,255,255,0.6);
    border-radius:3px;
}
.critical .res-fill { animation: pulse-bar 0.5s ease-in-out infinite alternate; }
@keyframes pulse-bar {
    from { opacity:1; }
    to { opacity:0.4; }
}
.status-row {
    margin-top:8px;
    font-size:9px;
    letter-spacing:2px;
    color:#555;
    text-transform:uppercase;
}
.status-row .status-val { color:#0af; }
#zoom-hint {
    position:fixed;
    bottom:20px;
    right:20px;
    font-size:9px;
    letter-spacing:2px;
    color:#2a2a2a;
    pointer-events:none;
    z-index:10;
}
#gameover {
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.75);
    z-index:100;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    text-align:center;
}
#gameover.active { display:flex; }
#gameover h1 {
    font-family:'Orbitron', sans-serif;
    font-size:28px;
    letter-spacing:6px;
    color:#ff3344;
    margin:0 0 12px 0;
    text-transform:uppercase;
}
#gameover p {
    font-size:11px;
    letter-spacing:3px;
    color:#777;
    margin:0 0 28px 0;
    text-transform:uppercase;
}
#gameover button {
    font-family:'Share Tech Mono', monospace;
    font-size:11px;
    letter-spacing:3px;
    text-transform:uppercase;
    background:none;
    border:1px solid #0af;
    color:#0af;
    padding:10px 28px;
    cursor:pointer;
}
#gameover button:hover { background:rgba(0,170,255,0.1); }

#debug-panel {
    position:fixed;
    bottom:20px;
    left:20px;
    width:340px;
    max-height:260px;
    background:rgba(0,0,0,0.82);
    border:1px solid #1a3a1a;
    border-radius:4px;
    z-index:20;
    display:flex;
    flex-direction:column;
    font-family:'Share Tech Mono', monospace;
    font-size:9px;
    pointer-events:auto;
}
#debug-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:5px 8px;
    border-bottom:1px solid #1a3a1a;
    background:rgba(0,40,0,0.6);
    cursor:pointer;
    user-select:none;
    letter-spacing:2px;
    color:#3f3;
    font-size:9px;
}
#debug-header span { color:#1a5c1a; }
#debug-log {
    overflow-y:auto;
    flex:1;
    padding:6px 8px;
    line-height:1.6;
}
#debug-log::-webkit-scrollbar { width:4px; }
#debug-log::-webkit-scrollbar-track { background:transparent; }
#debug-log::-webkit-scrollbar-thumb { background:#1a4a1a; border-radius:2px; }
.dl { color:#2a2a2a; }
.dl.info  { color:#3a7a3a; }
.dl.warn  { color:#aaaa00; }
.dl.crit  { color:#ff4444; }
.dl.state { color:#00aaff; }
.dl.score { color:#448844; }
.dl.skip  { color:#555; }
.dl.good  { color:#44ff44; }
#debug-panel.collapsed #debug-log { display:none; }
</style>
</head>
<body>
<canvas id="sim"></canvas>

<div id="hud">
    <h2>Ship Status</h2>
    <div class="res-row" id="row-oxygen">
        <div class="res-label"><span>OXYGEN</span><span id="val-oxygen">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-oxygen" style="background:#00bbff;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-water">
        <div class="res-label"><span>WATER</span><span id="val-water">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-water" style="background:#3366ff;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-food">
        <div class="res-label"><span>FOOD</span><span id="val-food">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-food" style="background:#44dd77;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-fuel">
        <div class="res-label"><span>FUEL</span><span id="val-fuel">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-fuel" style="background:#ffaa00;width:100%"></div></div>
    </div>
    <div class="res-row" id="row-integrity">
        <div class="res-label"><span>INTEGRITY</span><span id="val-integrity">100</span></div>
        <div class="res-track"><div class="res-fill" id="bar-integrity" style="background:#cc44ff;width:100%"></div></div>
    </div>
    <div class="status-row">STATE: <span class="status-val" id="state-label">STANDBY</span></div>
    <div class="status-row">TARGET: <span class="status-val" id="target-label">â€”</span></div>
    <div style="margin-top:12px; pointer-events:auto;">
    <button id="follow-btn" style="
        width:100%;
        font-family:'Share Tech Mono', monospace;
        font-size:10px;
        letter-spacing:2px;
        text-transform:uppercase;
        background:none;
        border:1px solid #0af;
        color:#0af;
        padding:6px;
        cursor:pointer;">
        Follow Camera: OFF
    </button>
</div>

</div>

<div id="zoom-hint">SCROLL TO ZOOM &nbsp;Â·&nbsp; DRAG TO PAN</div>

<div id="debug-panel">
    <div id="debug-header" onclick="toggleDebug()">
        â—ˆ AI DEBUG LOG <span id="debug-count">[0]</span>
    </div>
    <div id="debug-log"></div>
</div>

<div id="gameover">
    <h1>Mission Failed</h1>
    <p id="gameover-reason">Critical resource depleted</p>
    <button onclick="location.reload()">Restart Mission</button>
</div>

<script>
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

// =============================
// DEBUG LOG
// =============================
const MAX_LOG = 200;
let debugLines = [];
let debugCount = 0;
let debugCollapsed = false;

function toggleDebug(){
    debugCollapsed = !debugCollapsed;
    document.getElementById("debug-panel").classList.toggle("collapsed", debugCollapsed);
}

function dbg(msg, type="info"){
    const now = (performance.now() / 1000).toFixed(1);
    debugLines.push({ msg:`[${now}s] ${msg}`, type });
    if(debugLines.length > MAX_LOG) debugLines.shift();
    debugCount++;
    renderDebug();
}

function renderDebug(){
    const log = document.getElementById("debug-log");
    document.getElementById("debug-count").textContent = `[${debugCount}]`;
    log.innerHTML = debugLines.map(l =>
        `<div class="dl ${l.type}">${l.msg}</div>`
    ).join("");
    log.scrollTop = log.scrollHeight;
}

// Throttle: only log chooseNext details every N ms to avoid spam
let lastChooseLog = 0;
const CHOOSE_LOG_INTERVAL = 2000;
let lastOxyWarn = 0;

// =============================
// CAMERA
// =============================
const SOLAR_SCALE = 2.5; // multiplier applied to all orbit radii

function overviewZoom(){
    // Zoom level that fits the outermost orbit (factor 0.96) with a 10% margin
    const outerR = Math.min(canvas.width, canvas.height) / 2 * 0.96 * SOLAR_SCALE;
    return (Math.min(canvas.width, canvas.height) / 2 / outerR) * 0.88;
}

const FOLLOW_ZOOM = 3.0;

const camera = { 
    zoom: 1,
    targetZoom: 1,
    panX: 0, 
    panY: 0,
    follow: false
};


canvas.addEventListener("wheel", e => {
    e.preventDefault();
    if(camera.follow) return;
    const f = e.deltaY < 0 ? 1.12 : 0.89;
    const mx = e.clientX - canvas.width / 2;
    const my = e.clientY - canvas.height / 2;
    camera.panX = camera.panX * f + mx * (1 - f);
    camera.panY = camera.panY * f + my * (1 - f);
    const newZoom = Math.max(0.1, Math.min(14, camera.zoom * f));
    camera.zoom = newZoom;
    camera.targetZoom = newZoom;
}, { passive: false });

let dragging = false, dragStart = {x:0,y:0}, panStart = {x:0,y:0};
canvas.addEventListener("mousedown", e => {
    dragging = true;
    dragStart = { x: e.clientX, y: e.clientY };
    panStart  = { x: camera.panX, y: camera.panY };
});
canvas.addEventListener("mousemove", e => {
    if(!dragging || camera.follow) return;
    camera.panX = panStart.x + (e.clientX - dragStart.x);
    camera.panY = panStart.y + (e.clientY - dragStart.y);
});
window.addEventListener("mouseup", () => dragging = false);

function applyCamera(){
    ctx.translate(canvas.width/2 + camera.panX, canvas.height/2 + camera.panY);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-canvas.width/2, -canvas.height/2);
}
const followBtn = document.getElementById("follow-btn");

followBtn.addEventListener("click", () => {
    camera.follow = !camera.follow;

    followBtn.textContent = 
        "Follow Camera: " + (camera.follow ? "ON" : "OFF");

    if(camera.follow){
        camera.targetZoom = FOLLOW_ZOOM;
    } else {
        camera.targetZoom = overviewZoom();
        camera.panX = 0;
        camera.panY = 0;
    }
});


// =============================
// RESIZE + STARS
// =============================
let stars = [];
function buildStars(){
    stars = [];
    for(let i = 0; i < 550; i++){
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: Math.random() * 1.3 + 0.2,
            a: Math.random() * 0.7 + 0.3,
            tw: Math.random() * 3 + 1
        });
    }
}
function resize(){
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    buildStars();
    // Reset to overview zoom whenever window resizes
    if(!camera.follow){
        camera.zoom = overviewZoom();
        camera.targetZoom = camera.zoom;
    }
}
window.addEventListener("resize", resize);
resize();
// Set initial overview zoom after first resize
camera.zoom = overviewZoom();
camera.targetZoom = camera.zoom;

function center(){ return { x: canvas.width/2, y: canvas.height/2 }; }

function randRange(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
}


function drawStars(t){
    for(let s of stars){
        const twinkle = 0.6 + 0.4 * Math.sin(t / 1000 * s.tw);
        ctx.globalAlpha = s.a * twinkle;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// =============================
// COLOR UTILS
// =============================
function shiftColor(hex, amt){
    let r, g, b;
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    if(m){ r=parseInt(m[1],16); g=parseInt(m[2],16); b=parseInt(m[3],16); }
    else {
        const tmp=document.createElement('canvas'); tmp.width=tmp.height=1;
        const tc=tmp.getContext('2d'); tc.fillStyle=hex; tc.fillRect(0,0,1,1);
        const d=tc.getImageData(0,0,1,1).data; r=d[0];g=d[1];b=d[2];
    }
    r=Math.min(255,Math.max(0,Math.round(r+amt*255)));
    g=Math.min(255,Math.max(0,Math.round(g+amt*255)));
    b=Math.min(255,Math.max(0,Math.round(b+amt*255)));
    return `rgb(${r},${g},${b})`;
}
const lighten = (h, a) => shiftColor(h,  a);
const darken  = (h, a) => shiftColor(h, -a);

// =============================
// SUN
// =============================
function drawSun(t){
    const c = center();
    const pulse = 1 + 0.02 * Math.sin(t / 600);

    // Danger zone ring â€” pulsing red warning
    const dangerRadius = ship.SUN_DANGER_RADIUS || 90;
    const dangerPulse = 0.3 + 0.15 * Math.sin(t / 400);
    ctx.beginPath();
    ctx.arc(c.x, c.y, dangerRadius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,60,20,${dangerPulse})`;
    ctx.lineWidth = 1.5 / camera.zoom;
    ctx.setLineDash([4 / camera.zoom, 6 / camera.zoom]);
    ctx.stroke();
    ctx.setLineDash([]);

    for(let i = 3; i > 0; i--){
        const grad = ctx.createRadialGradient(c.x, c.y, 24, c.x, c.y, 40*i*pulse);
        grad.addColorStop(0, 'rgba(255,200,50,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 40*i*pulse, 0, Math.PI*2);
        ctx.fill();
    }

    const sunGrad = ctx.createRadialGradient(c.x-8, c.y-8, 4, c.x, c.y, 28*pulse);
    sunGrad.addColorStop(0, '#fff8c0');
    sunGrad.addColorStop(0.4, '#ffcc00');
    sunGrad.addColorStop(1, '#ff6600');
    ctx.fillStyle = sunGrad;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 28*pulse, 0, Math.PI*2);
    ctx.fill();
}

// =============================
// PLANETS
// =============================
function hexToRgba(hex, a){
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    return m ? `rgba(${parseInt(m[1],16)},${parseInt(m[2],16)},${parseInt(m[3],16)},${a})` : hex;
}

class Planet {
    constructor(name, orbitFactor, size, color, resource, glowColor){
        this.name = name;
        this.orbitFactor = orbitFactor;
        this.size = size;
        this.color = color;
        this.glowColor = glowColor || color;
        this.glowRGBA = hexToRgba(this.glowColor, 0.2);
        this.resource = resource;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 0.00005 + Math.random() * 0.00003;
    }

    orbitRadius(){
        return Math.min(canvas.width, canvas.height) / 2 * this.orbitFactor * SOLAR_SCALE;
    }

    update(dt){ this.angle += this.speed * dt; }

    position(){
        const c = center();
        const r = this.orbitRadius();
        return { x: c.x + Math.cos(this.angle)*r, y: c.y + Math.sin(this.angle)*r };
    }

    draw(t){
        const p  = this.position();
        const c  = center();
        const r  = this.orbitRadius();

        // Orbit ring
        ctx.beginPath();
        ctx.arc(c.x, c.y, r, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.04)";
        ctx.lineWidth = 1 / camera.zoom;
        ctx.stroke();

        // Atmosphere glow
        const pulse = 1 + 0.04 * Math.sin(t / 800);
        const grad = ctx.createRadialGradient(p.x, p.y, this.size*0.5, p.x, p.y, this.size*3*pulse);
        grad.addColorStop(0, this.glowRGBA);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.beginPath();
        ctx.arc(p.x, p.y, this.size*3*pulse, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Planet body
        const bg = ctx.createRadialGradient(p.x - this.size*0.3, p.y - this.size*0.3, this.size*0.1, p.x, p.y, this.size);
        bg.addColorStop(0, lighten(this.color, 0.4));
        bg.addColorStop(1, darken(this.color, 0.4));
        ctx.fillStyle = bg;
        ctx.beginPath();
        ctx.arc(p.x, p.y, this.size, 0, Math.PI*2);
        ctx.fill();

        // Label
        ctx.save();
        ctx.font = `${9 / camera.zoom}px 'Share Tech Mono'`;
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.textAlign = "center";
        ctx.fillText(this.name.toUpperCase(), p.x, p.y + this.size + 14 / camera.zoom);
        ctx.restore();
    }
}

const planets = [
    new Planet("Oxygen", 0.22, 14, "#00aaff", "oxygen", "#00aaff"),
    new Planet("Food",   0.40, 15, "#44cc66", "food",   "#44cc66"),
    new Planet("Water",  0.58, 13, "#2255dd", "water",  "#2255dd"),
    new Planet("Fuel",   0.76, 17, "#dd8800", "fuel",   "#dd8800"),
    new Planet("Repair", 0.96, 16, "#aa44ff", "repair", "#aa44ff"),
];

// =============================
// THRUST TRAIL
// =============================
class Trail {
    constructor(){ this.particles = []; }

    emit(x, y, vx, vy, color){
        for(let i = 0; i < 3; i++){
            this.particles.push({
                x, y,
                vx: vx * -0.08 + (Math.random()-0.5) * 0.8,
                vy: vy * -0.08 + (Math.random()-0.5) * 0.8,
                life: 1,
                decay: 0.025 + Math.random() * 0.02,
                size: 0.6 + Math.random() * 0.8,
                color
            });
        }
    }

    update(dt){
        for(let p of this.particles){
            p.x += p.vx * dt * 0.1;
            p.y += p.vy * dt * 0.1;
            p.life -= p.decay * dt * 0.1;
        }
        this.particles = this.particles.filter(p => p.life > 0);
    }

    draw(){
        for(let p of this.particles){
            ctx.globalAlpha = p.life * 0.7;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

const trail = new Trail();

// =============================
// PKG ECHO RINGS
// =============================
const pkgEchoRings = [];

function triggerSpawn(x, y){
    // Three staggered echo rings
    pkgEchoRings.push({ x, y, radius: 0, life: 1, delay: 0   });
    pkgEchoRings.push({ x, y, radius: 0, life: 1, delay: 120 });
    pkgEchoRings.push({ x, y, radius: 0, life: 1, delay: 240 });
}

function updateSpawnParticles(dt){
    for(let r of pkgEchoRings){
        if(r.delay > 0){ r.delay -= dt; continue; }
        r.radius += 0.12 * dt;
        r.life   -= 0.0018 * dt;
    }
    for(let i = pkgEchoRings.length - 1; i >= 0; i--)
        if(pkgEchoRings[i].life <= 0) pkgEchoRings.splice(i, 1);
}

function drawSpawnParticles(){
    for(let r of pkgEchoRings){
        if(r.delay > 0 || r.life <= 0) continue;
        ctx.globalAlpha = r.life * 0.7;
        ctx.strokeStyle = '#ffdd88';
        ctx.lineWidth   = 1.5 * r.life;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

// =============================
// DUST / PLUME PARTICLE SYSTEM
// =============================
const dustParticles = [];

function emitLandingDust(planet, surfaceAngle){
    const pp = planet.position();
    const sx = pp.x + Math.cos(surfaceAngle) * planet.size;
    const sy = pp.y + Math.sin(surfaceAngle) * planet.size;

    const dustColors = [
        hexToRgba(planet.color, 0.6),
        hexToRgba(planet.color, 0.3),
        'rgba(200,200,200,0.4)',
        'rgba(255,255,255,0.25)',
        hexToRgba(planet.color, 0.15),
    ];

    for(let i = 0; i < 45; i++){
        // Spread dust along the surface tangent (perpendicular to surface normal)
        const tangent = surfaceAngle + Math.PI / 2;
        const spread = (Math.random() - 0.5) * 2.2;
        const outward = 0.3 + Math.random() * 1.8;
        const vx = Math.cos(surfaceAngle) * outward * 0.4 + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * outward * 0.4 + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 4,
            y: sy + (Math.random() - 0.5) * 4,
            vx, vy,
            life: 1,
            decay: 0.006 + Math.random() * 0.008,
            size: 1.0 + Math.random() * 3.5,
            color: dustColors[Math.floor(Math.random() * dustColors.length)]
        });
    }
}

function emitTakeoffBlast(planet, surfaceAngle){
    const pp = planet.position();
    const sx = pp.x + Math.cos(surfaceAngle) * (planet.size + 2);
    const sy = pp.y + Math.sin(surfaceAngle) * (planet.size + 2);

    // Fiery exhaust colors
    const fireColors = [
        'rgba(255,200,60,0.9)',
        'rgba(255,140,30,0.8)',
        'rgba(255,80,10,0.7)',
        'rgba(255,255,200,0.6)',
        'rgba(255,100,50,0.5)',
    ];

    // Dust kicked up by takeoff
    const dustColors = [
        hexToRgba(planet.color, 0.5),
        'rgba(200,200,200,0.3)',
        hexToRgba(planet.color, 0.2),
    ];

    // Fire blast downward (into planet surface)
    for(let i = 0; i < 35; i++){
        const tangent = surfaceAngle + Math.PI / 2;
        const spread = (Math.random() - 0.5) * 1.5;
        // Particles go inward (opposite of surface normal) to simulate exhaust hitting ground
        const inward = -(0.5 + Math.random() * 2.0);
        const vx = Math.cos(surfaceAngle) * inward * 0.3 + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * inward * 0.3 + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 3,
            y: sy + (Math.random() - 0.5) * 3,
            vx, vy,
            life: 1,
            decay: 0.008 + Math.random() * 0.012,
            size: 0.8 + Math.random() * 2.5,
            color: fireColors[Math.floor(Math.random() * fireColors.length)]
        });
    }

    // Surface dust blowing outward along tangent
    for(let i = 0; i < 30; i++){
        const tangent = surfaceAngle + Math.PI / 2;
        const dir = Math.random() > 0.5 ? 1 : -1;
        const spread = dir * (0.8 + Math.random() * 2.5);
        const outward = 0.1 + Math.random() * 0.6;
        const vx = Math.cos(surfaceAngle) * outward + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * outward + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 6,
            y: sy + (Math.random() - 0.5) * 6,
            vx, vy,
            life: 1,
            decay: 0.004 + Math.random() * 0.006,
            size: 1.5 + Math.random() * 3.0,
            color: dustColors[Math.floor(Math.random() * dustColors.length)]
        });
    }
}

function updateDustParticles(dt){
    for(let p of dustParticles){
        p.x += p.vx * dt * 0.08;
        p.y += p.vy * dt * 0.08;
        p.vx *= 0.96;
        p.vy *= 0.96;
        p.life -= p.decay * dt * 0.1;
    }
    for(let i = dustParticles.length - 1; i >= 0; i--)
        if(dustParticles[i].life <= 0) dustParticles.splice(i, 1);
}

function drawDustParticles(){
    for(let p of dustParticles){
        if(p.life <= 0) continue;
        ctx.globalAlpha = p.life * 0.8;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (0.4 + p.life * 0.6), 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// =============================
// PACKAGE (spawns on planet)
// =============================
class Package {
    constructor(){
        this.active = false;
        this.planet = null;
        this.surfaceAngle = 0;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.spawnAnim = 0; // 0 to 1 pop-in animation
    }

    spawn(planet, shipSurfaceAngle){
    this.active = true;
    this.planet = planet;
    this.spawnAnim = 0;

    // Fully random angle
    let angle;
    let attempts = 0;

    do {
        angle = Math.random() * Math.PI * 2;
        attempts++;
        // Keep trying if too close to landing site
    } while(
        attempts < 30 &&
        Math.abs(angleDiff(angle, shipSurfaceAngle)) < 0.9   // ~50 degrees away
    );

    this.surfaceAngle = angle;

    // Trigger visible spawn burst on surface
    const pp = planet.position();
    const r = planet.size + 6;

    const sx = pp.x + Math.cos(this.surfaceAngle) * r;
    const sy = pp.y + Math.sin(this.surfaceAngle) * r;

    triggerSpawn(sx, sy);
}


    dismiss(){
        this.active = false;
        this.planet = null;
    }

    update(dt){
        if(!this.active) return;
        this.bobPhase += dt * 0.004;
        if(this.spawnAnim < 1) this.spawnAnim = Math.min(1, this.spawnAnim + dt * 0.004);
    }

    draw(t){
        if(!this.active) return;

        const pp = this.planet.position();
        const r = this.planet.size + 6;
        const bob = Math.sin(this.bobPhase) * 1.5;

        const x = pp.x + Math.cos(this.surfaceAngle) * (r + bob);
        const y = pp.y + Math.sin(this.surfaceAngle) * (r + bob);

        // Eased pop-in scale
        const ease = 1 - Math.pow(1 - this.spawnAnim, 3);
        const scale = ease * 0.22;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.surfaceAngle + Math.PI / 2);
        ctx.scale(scale, scale);

        // Glow underneath
        const glow = ctx.createRadialGradient(0, 0, 2, 0, 0, 30);
        glow.addColorStop(0, 'rgba(255,220,80,0.4)');
        glow.addColorStop(1, 'rgba(255,220,80,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI * 2);
        ctx.fill();

        // Crate body
        ctx.fillStyle = "#cc8800";
        ctx.strokeStyle = "#aa6600";
        ctx.lineWidth = 2;
        if(ctx.roundRect){
            ctx.beginPath();
            ctx.roundRect(-12, -20, 24, 22, 3);
            ctx.fill();
            ctx.stroke();
        } else {
            ctx.fillRect(-12, -20, 24, 22);
            ctx.strokeRect(-12, -20, 24, 22);
        }

        // Crate highlight
        ctx.fillStyle = "rgba(255,200,0,0.5)";
        ctx.fillRect(-8, -16, 16, 14);

        // Crate cross straps
        ctx.strokeStyle = "#886600";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-12, -20); ctx.lineTo(12, 2);
        ctx.moveTo(12, -20); ctx.lineTo(-12, 2);
        ctx.stroke();

        // Resource icon dot (glowing)
        const resColors = { oxygen:'#00ccff', water:'#4488ff', food:'#44dd77', fuel:'#ffaa00' };
        const rc = resColors[this.planet.resource] || '#fff';
        ctx.fillStyle = rc;
        ctx.shadowColor = rc;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, -9, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

const pkg = new Package();

// =============================
// ANGLE UTILS
// =============================
function lerpAngle(current, target, t){
    let diff = target - current;
    while(diff >  Math.PI) diff -= Math.PI * 2;
    while(diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * t;
}

function angleDiff(a, b){
    let d = b - a;
    while(d >  Math.PI) d -= Math.PI * 2;
    while(d < -Math.PI) d += Math.PI * 2;
    return d;
}

// =============================
// SHIP
// =============================
class Ship {
    constructor(){
        const c = center();
        this.x = c.x;
        this.y = c.y - 200;
        this.vx = 0;
        this.vy = 0;
        this.rotation = 0;
        this.thrusting = false;
        // Loading phase
        this.loadingTimer = 0;
        this.loadingResource = null;
        this.loadingDuration = 2000; // 2 seconds

        this.state = "idle";
        this.target = null;
        this.landedPlanet = null;
        this.surfaceAngle = 0;

        this.resources = {
            oxygen: randRange(50, 100),
            water:  randRange(50, 100),
            food:   randRange(50, 100),
            fuel:   randRange(50, 100)
        };
        this.integrity = 100;
        this.SUN_DANGER_RADIUS = 90; // world-space radius around sun center
        this.evaRefillRate = 0;
        this.evaResource = null;

        // Spawn
        this.spawned = false;
        this.spawnTimer = 0;
        this.SPAWN_DELAY = 1200;

        // Warp-in animation
        this.warpAnim = 0;          // 0 â†’ 1 over warpDuration ms
        this.warpDuration = 700;

        // Post-spawn hold before AI engages
        this.holdTimer = 0;
        this.HOLD_DURATION = 4000;

        // Takeoff effect
        this.takeoffTimer = 0;
        this.takeoffBlastEmitted = false;

        // Idle wander
        this.wanderX = 0;
        this.wanderY = 0;
        this._pickWander();
                // Smooth landing
        this.landingProgress = 0;

        // Prevent repeat planet visits
        this.lastPlanet = null;

    }

    _pickWander(){
        // Wander within inner system (roughly between innermost and mid orbits)
        const c = center();
        const wanderRadius = Math.min(canvas.width, canvas.height) / 2 * 0.35 * SOLAR_SCALE;
        const angle = Math.random() * Math.PI * 2;
        const dist  = wanderRadius * (0.3 + Math.random() * 0.7);
        this.wanderX = c.x + Math.cos(angle) * dist;
        this.wanderY = c.y + Math.sin(angle) * dist;
    }

    update(dt){
        // Spawn countdown
        if(!this.spawned){
            this.spawnTimer += dt;
            if(this.spawnTimer >= this.SPAWN_DELAY){
                this.spawned = true;
                triggerSpawn(this.x, this.y);
            }
            return;
        }

        // Warp-in progress
        if(this.warpAnim < 1) this.warpAnim = Math.min(1, this.warpAnim + dt / this.warpDuration);

        // Post-spawn hold
        if(this.holdTimer < this.HOLD_DURATION) this.holdTimer += dt;

        // RESOURCE DRAIN
        let oxygenDrain = 0.0004; // base drain inside ship

        if(this.state === "eva"){
            oxygenDrain = 0.0025; // heavy drain outside
        }
        else if(this.state === "transfer" || this.state === "takeoff"){
            oxygenDrain = 0.0007; // slightly higher under thrust
        }

        this.resources.oxygen -= oxygenDrain * dt;

        this.resources.water -= 0.001 * dt;
        this.resources.food  -= 0.0006 * dt;

        if(this.state === "transfer" || this.state === "takeoff")
            this.resources.fuel -= 0.0015 * dt;


        for(let r in this.resources)
            this.resources[r] = Math.max(0, this.resources[r]);

        // SUN PROXIMITY â€” integrity damage when flying too close
        if(this.state !== "landed" && this.state !== "eva" && this.state !== "loading"){
            const c = center();
            const sunDist = Math.hypot(this.x - c.x, this.y - c.y);
            if(sunDist < this.SUN_DANGER_RADIUS){
                const intensity = 1 - sunDist / this.SUN_DANGER_RADIUS;
                this.integrity = Math.max(0, this.integrity - 0.008 * intensity * dt);
            }
        }

        // TRANSFER â€” slow thrust, always tracking moving target
        if(this.state === "transfer"){
            const tp = this.target.position();
            const dx = tp.x - this.x;
            const dy = tp.y - this.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);

            const maxSpeed = 1.4;
            const arriveRadius = 120;
            // Use surface distance (not center distance) so the ship doesn't
            // slow below the planet's orbital speed and get stuck chasing it
            const surfaceDist = Math.max(0, dist - this.target.size);
            let desiredSpeed = surfaceDist < arriveRadius ? maxSpeed * (surfaceDist / arriveRadius) : maxSpeed;
            // Minimum speed guarantees we always overtake the moving planet
            desiredSpeed = Math.max(desiredSpeed, 0.55);

            const desiredVX = Math.cos(angle) * desiredSpeed;
            const desiredVY = Math.sin(angle) * desiredSpeed;

            const steerStrength = 0.08;
            this.vx += (desiredVX - this.vx) * steerStrength;
            this.vy += (desiredVY - this.vy) * steerStrength;

            this.thrusting = dist > this.target.size + 10;
            if(this.thrusting){
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
            }

            if(dist <= this.target.size + 8){
                this.land();
            }
        }

        // LANDED / EVA â€” stick to planet surface
        if(this.state === "landed" || this.state === "eva" || this.state === "loading"){
            const pp = this.landedPlanet.position();
            this.x = pp.x + Math.cos(this.surfaceAngle) * this.landedPlanet.size;
            this.y = pp.y + Math.sin(this.surfaceAngle) * this.landedPlanet.size;
            this.rotation = this.surfaceAngle + Math.PI/2;
            this.thrusting = false;
        }
// =============================
// LOADING
// =============================
if(this.state === "loading"){
    this.loadingTimer += dt;

    const progress = this.loadingTimer / this.loadingDuration;

    if(this.loadingResource){
        const type = this.loadingResource;

        if(type === "repair"){
            // Restore integrity instead of a resource
            this.integrity = Math.min(100, this.integrity + 0.06 * dt);
        } else {
            // Gradual refill
            this.resources[type] = Math.min(
                100,
                this.resources[type] + 0.05 * dt
            );
        }
    }

    if(progress >= 1){
        this.loadingResource = null;
        dbg(`â¬† LOADING complete â†’ TAKEOFF (O2=${this.resources.oxygen.toFixed(0)} FUEL=${this.resources.fuel.toFixed(0)})`, "state");
        this.state = "takeoff";
    }

    this.thrusting = false;
    this.updateHUD();  // âœ… add this
    return;
}

        // TAKEOFF
        if(this.state === "takeoff"){
            this.takeoffTimer += dt;

            // Emit the big takeoff blast once at the start
            if(!this.takeoffBlastEmitted){
                this.takeoffBlastEmitted = true;
                emitTakeoffBlast(this.landedPlanet, this.surfaceAngle);
                // Structural stress from launch
                this.integrity = Math.max(0, this.integrity - (2 + Math.random() * 4));
            }

            // Continuous exhaust during takeoff
            if(this.takeoffTimer % 3 < 2){
                const pp = this.landedPlanet.position();
                const ex = pp.x + Math.cos(this.surfaceAngle) * (this.landedPlanet.size - 1);
                const ey = pp.y + Math.sin(this.surfaceAngle) * (this.landedPlanet.size - 1);
                const tangent = this.surfaceAngle + Math.PI / 2;
                for(let i = 0; i < 2; i++){
                    dustParticles.push({
                        x: this.x, y: this.y,
                        vx: -Math.cos(this.surfaceAngle) * (0.5 + Math.random() * 1.5) + (Math.random()-0.5)*0.5,
                        vy: -Math.sin(this.surfaceAngle) * (0.5 + Math.random() * 1.5) + (Math.random()-0.5)*0.5,
                        life: 1,
                        decay: 0.012 + Math.random() * 0.015,
                        size: 0.6 + Math.random() * 1.8,
                        color: ['rgba(255,180,60,0.8)','rgba(255,100,20,0.6)','rgba(255,220,120,0.7)'][Math.floor(Math.random()*3)]
                    });
                }
            }

            this.vx += Math.cos(this.surfaceAngle) * 0.00012 * dt;
            this.vy += Math.sin(this.surfaceAngle) * 0.00012 * dt;
            this.thrusting = true;
            trail.emit(this.x, this.y, this.vx, this.vy, "#ffaa44");

            if(this.distanceTo(this.landedPlanet.position()) > this.landedPlanet.size + 120){
                dbg(`ðŸ”„ TAKEOFF complete â†’ IDLE (O2=${this.resources.oxygen.toFixed(0)})`, "state");
                this.state = "idle";
                this.landedPlanet = null;
                this.target = null;
                this.thrusting = false;
                this.takeoffTimer = 0;
                this.takeoffBlastEmitted = false;
            }
        }

        // IDLE WANDER
        if(this.state === "idle"){
            const dx = this.wanderX - this.x;
            const dy = this.wanderY - this.y;
            const dist = Math.hypot(dx, dy);
            if(dist < 30){
                this._pickWander();
            } else {
                const angle = Math.atan2(dy, dx);
                const thrust = 0.00012;
                this.vx += Math.cos(angle) * thrust * dt;
                this.vy += Math.sin(angle) * thrust * dt;
                const spd = Math.hypot(this.vx, this.vy);
                if(spd > 0.18){ this.vx *= 0.18/spd; this.vy *= 0.18/spd; }
            }
            this.thrusting = Math.hypot(this.vx, this.vy) > 0.05;
            if(this.thrusting)
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
        }

        // PHYSICS
        if(this.state === "transfer" || this.state === "takeoff" || this.state === "idle"){
            this.x += this.vx * dt * 0.1;
            this.y += this.vy * dt * 0.1;
            if(Math.hypot(this.vx, this.vy) > 0.01){
                let targetRotation = Math.atan2(this.vy, this.vx) + Math.PI/2;

                if(this.state === "transfer" && this.target){
                    const tp = this.target.position();
                    const dist = Math.hypot(tp.x - this.x, tp.y - this.y);
                    const blendStart = 120;
                    if(dist < blendStart){
                        const surfAngle = Math.atan2(this.y - tp.y, this.x - tp.x);
                        const landingRot = surfAngle + Math.PI/2;
                        const blend = 1 - dist / blendStart;
                        targetRotation = lerpAngle(targetRotation, landingRot, blend);
                    }
                }

                this.rotation = lerpAngle(this.rotation, targetRotation, Math.min(1, 0.005 * dt));
            }
        }

        // Global speed cap
        const maxSpd = 1.4;
        const spd = Math.hypot(this.vx, this.vy);
        if(spd > maxSpd){ this.vx *= maxSpd/spd; this.vy *= maxSpd/spd; }

        // Keep wander target within the inner system world bounds
        const c2 = center();
        const maxWander = Math.min(canvas.width, canvas.height) / 2 * 0.38 * SOLAR_SCALE;
        const wx = this.wanderX - c2.x, wy = this.wanderY - c2.y;
        if(Math.hypot(wx, wy) > maxWander){
            const wa = Math.atan2(wy, wx);
            this.wanderX = c2.x + Math.cos(wa) * maxWander;
            this.wanderY = c2.y + Math.sin(wa) * maxWander;
        }

        this.updateHUD();
    }

    land(){
        this.state = "landed";
        dbg(`âœˆ LANDED on ${this.target.name.toUpperCase()} (resource: ${this.target.resource})`, "state");
        this.landedPlanet = this.target;

        const pp = this.landedPlanet.position();
        this.surfaceAngle = Math.atan2(this.y - pp.y, this.x - pp.x);
        this.x = pp.x + Math.cos(this.surfaceAngle) * this.landedPlanet.size;
        this.y = pp.y + Math.sin(this.surfaceAngle) * this.landedPlanet.size;
        this.vx = 0;
        this.vy = 0;

        // Landing dust plume!
        emitLandingDust(this.landedPlanet, this.surfaceAngle);

        // Impact stress â€” repair planet is a soft dock, others are harder landings
        const impactDmg = this.landedPlanet.resource === "repair"
            ? 1 + Math.random() * 2
            : 3 + Math.random() * 6;
        this.integrity = Math.max(0, this.integrity - impactDmg);

        this.evaResource = this.landedPlanet.resource;
        if(this.evaResource === "repair"){
            // Repair planet restores integrity, not a normal resource
            this.evaRefillRate = 0;
        } else {
            const deficit = 100 - this.resources[this.evaResource];
            this.evaRefillRate = deficit / 2000;
        }

        // Spawn a package on the planet
        pkg.spawn(this.landedPlanet, this.surfaceAngle);

        // Deploy astronaut to walk to the package
        astronaut.deploy(this);
    }

    distanceTo(p){ return Math.hypot(this.x - p.x, this.y - p.y); }

    updateHUD(){

    // =============================
    // RESOURCE BARS
    // =============================
    for(let key of ['oxygen','water','food','fuel']){

        const val = Math.round(this.resources[key]);

        const bar   = document.getElementById('bar-' + key);
        const valEl = document.getElementById('val-' + key);
        const rowEl = document.getElementById('row-' + key);

        if(bar)   bar.style.width = val + '%';
        if(valEl) valEl.textContent = val;

        if(rowEl)
            rowEl.classList.toggle('critical', val < 15);

        if(val <= 0 && this.spawned && !gameOver)
            triggerGameOver(key);
    }

    // INTEGRITY BAR
    const intVal = Math.round(this.integrity);
    const intBar   = document.getElementById('bar-integrity');
    const intValEl = document.getElementById('val-integrity');
    const intRowEl = document.getElementById('row-integrity');
    if(intBar)   intBar.style.width = intVal + '%';
    if(intValEl) intValEl.textContent = intVal;
    if(intRowEl) intRowEl.classList.toggle('critical', intVal < 20);
    if(intVal <= 0 && this.spawned && !gameOver)
        triggerGameOver('integrity');


    // =============================
    // STATE LABEL
    // =============================
    const stateEl  = document.getElementById('state-label');
    const targetEl = document.getElementById('target-label');

    if(stateEl){
        if(!this.spawned){
            stateEl.textContent = "STANDBY";
        }
        else if(this.state === "loading"){
            const pct = Math.min(
                100,
                Math.floor((this.loadingTimer / this.loadingDuration) * 100)
            );
            const resName = this.loadingResource === "repair"
                ? "HULL"
                : this.loadingResource
                    ? this.loadingResource.toUpperCase()
                    : "CARGO";
            const verb = this.loadingResource === "repair" ? "REPAIRING " : "LOADING ";
            stateEl.textContent = verb + resName + " " + pct + "%";
        }
        else{
            stateEl.textContent = this.state.toUpperCase();
        }
    }
    // =============================
    // TARGET LABEL
    // =============================
    if(targetEl){
        targetEl.textContent =
            this.target ? this.target.name.toUpperCase() : "â€”";
    }
}

    draw(){
        if(!this.spawned) return;

        // â”€â”€ Warp-in effect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if(this.warpAnim < 1){
            const t = this.warpAnim;
            // Ease out: starts fast, settles to normal
            const ease = 1 - Math.pow(1 - t, 3);

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            // Horizontal warp streak â€” wide & thin, collapses to ship
            const streakW = (1 - ease) * 320 + 20;
            const streakH = ease * 22 + (1 - ease) * 2;
            const streakAlpha = (1 - ease) * 0.85;

            // Outer soft streak
            const sg = ctx.createLinearGradient(-streakW, 0, streakW, 0);
            sg.addColorStop(0,   'rgba(100,200,255,0)');
            sg.addColorStop(0.3, `rgba(140,220,255,${streakAlpha * 0.5})`);
            sg.addColorStop(0.5, `rgba(220,240,255,${streakAlpha})`);
            sg.addColorStop(0.7, `rgba(140,220,255,${streakAlpha * 0.5})`);
            sg.addColorStop(1,   'rgba(100,200,255,0)');
            ctx.fillStyle = sg;
            ctx.fillRect(-streakW, -streakH / 2, streakW * 2, streakH);

            // Bright core line
            const cg = ctx.createLinearGradient(-streakW * 0.6, 0, streakW * 0.6, 0);
            cg.addColorStop(0,   'rgba(255,255,255,0)');
            cg.addColorStop(0.5, `rgba(255,255,255,${streakAlpha * 0.9})`);
            cg.addColorStop(1,   'rgba(255,255,255,0)');
            ctx.fillStyle = cg;
            ctx.fillRect(-streakW * 0.6, -1, streakW * 1.2, 2);

            // Flash burst at centre when warp is fresh
            if(t < 0.25){
                const flashAlpha = (0.25 - t) / 0.25;
                const flashR = (1 - t) * 60 + 10;
                const fg = ctx.createRadialGradient(0, 0, 0, 0, 0, flashR);
                fg.addColorStop(0, `rgba(255,255,255,${flashAlpha * 0.9})`);
                fg.addColorStop(0.4, `rgba(160,220,255,${flashAlpha * 0.5})`);
                fg.addColorStop(1,   'rgba(100,180,255,0)');
                ctx.fillStyle = fg;
                ctx.beginPath();
                ctx.arc(0, 0, flashR, 0, Math.PI * 2);
                ctx.fill();
            }

            // Speed lines radiating outward (only early in warp)
            if(t < 0.55){
                const lineAlpha = (0.55 - t) / 0.55;
                ctx.strokeStyle = `rgba(180,230,255,${lineAlpha * 0.6})`;
                ctx.lineWidth = 0.8;
                const lineCount = 10;
                for(let i = 0; i < lineCount; i++){
                    const la = (i / lineCount) * Math.PI * 2;
                    const inner = 12 + (1 - t) * 10;
                    const outer = inner + (1 - t) * 80 * (0.4 + Math.random() * 0.6);
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(la) * inner, Math.sin(la) * inner);
                    ctx.lineTo(Math.cos(la) * outer, Math.sin(la) * outer);
                    ctx.stroke();
                }
            }

            ctx.restore();

            // Fade ship in over the second half of warp
            if(ease < 0.4) return;
            ctx.globalAlpha = (ease - 0.4) / 0.6;
        }
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.scale(0.2, 0.2);

        // Engine glow
        if(this.thrusting){
            const grd = ctx.createRadialGradient(0, 25, 2, 0, 25, 28);
            grd.addColorStop(0, 'rgba(255,180,60,0.9)');
            grd.addColorStop(1, 'rgba(255,80,0,0)');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(0, 25, 28, 0, Math.PI*2);
            ctx.fill();

            // Enhanced flame during takeoff
            if(this.state === "takeoff"){
                const flameLen = 35 + Math.sin(Date.now() * 0.02) * 10;
                const grd2 = ctx.createRadialGradient(0, 30, 3, 0, 30 + flameLen * 0.5, flameLen);
                grd2.addColorStop(0, 'rgba(255,255,200,0.8)');
                grd2.addColorStop(0.3, 'rgba(255,160,40,0.6)');
                grd2.addColorStop(0.6, 'rgba(255,80,10,0.3)');
                grd2.addColorStop(1, 'rgba(255,40,0,0)');
                ctx.fillStyle = grd2;
                ctx.beginPath();
                ctx.arc(0, 30 + flameLen * 0.3, flameLen, 0, Math.PI * 2);
                ctx.fill();

                // Inner white-hot core
                const coreLen = flameLen * 0.4;
                ctx.fillStyle = 'rgba(255,255,240,0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 28, 5, coreLen, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Body
        ctx.fillStyle = "#dde8f0";
        ctx.beginPath();
        if(ctx.roundRect) ctx.roundRect(-10, -28, 20, 44, 4);
        else ctx.rect(-10, -28, 20, 44);
        ctx.fill();

        // Cockpit
        ctx.fillStyle = "#00ccff";
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.ellipse(0, -18, 7, 10, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Wings
        ctx.fillStyle = "#aabbc8";
        ctx.beginPath();
        ctx.moveTo(-10, 5); ctx.lineTo(-26, 18); ctx.lineTo(-10, 14);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(10, 5); ctx.lineTo(26, 18); ctx.lineTo(10, 14);
        ctx.closePath(); ctx.fill();

        // Nozzle
        ctx.fillStyle = "#778899";
        ctx.fillRect(-7, 14, 14, 8);

        ctx.restore();
        ctx.globalAlpha = 1;
    }
}

const ship = new Ship();

// =============================
// ASTRONAUT
// =============================
class Astronaut {
    constructor(){
        this.state = "idle";
        this.planet = null;
        this.surfaceAngle = 0;
        this.targetAngle = 0;
        this.carrying = false;
        this.shipAngle = 0; // remember where the ship is
    }

    deploy(s){
        this.planet = s.landedPlanet;
        this.surfaceAngle = s.surfaceAngle + 0.08; // start just beside the ship
        this.shipAngle = s.surfaceAngle;

        // Walk to the package location
        if(pkg.active){
            this.targetAngle = pkg.surfaceAngle;
        } else {
            this.targetAngle = this.surfaceAngle + 0.6;
        }

        this.state = "walking_out";
        this.carrying = false;
        s.state = "eva";
    }

    update(dt){
        if(this.state === "idle") return;

        // Calculate angle difference properly
            const diff = angleDiff(this.surfaceAngle, this.targetAngle);

            if (Math.abs(diff) < 0.015) {

                if (this.state === "walking_out") {

                    this.carrying = true;
                    pkg.dismiss();

                    this.targetAngle = this.shipAngle;
                    this.state = "walking_back";

                } else if (this.state === "walking_back") {

                    this.carrying = false;
                    this.state = "idle";

                    ship.loadingResource = this.planet.resource;
                    ship.loadingTimer = 0;
                    ship.state = "loading";
                }

            } else {

                // Slower walking speed
                const step = angleDiff(this.surfaceAngle, this.targetAngle);
                const walkSpeed = 0.02;      // slowed
                const move = Math.sign(step) * Math.min(Math.abs(step), walkSpeed);

                this.surfaceAngle += move * dt * 0.035; // slowed
            }
        }

    

    draw(t){
        if(this.state === "idle") return;

        const p = this.planet.position();
        const r = this.planet.size + 4;

        const walking = Math.abs(angleDiff(this.surfaceAngle, this.targetAngle)) > 0.02;
        const bob  = walking ? Math.sin(t * 0.015) * 1.2 : 0;
        const lean = walking ? Math.sin(t * 0.008) * 0.07 : 0;

        const x = p.x + Math.cos(this.surfaceAngle) * r;
        const y = p.y + Math.sin(this.surfaceAngle) * r;
        const bobX = -Math.sin(this.surfaceAngle) * bob;
        const bobY =  Math.cos(this.surfaceAngle) * bob;

        ctx.save();
        ctx.translate(x + bobX, y + bobY);
        ctx.rotate(this.surfaceAngle + Math.PI/2 + lean);
        ctx.scale(0.2, 0.2);

        // Helmet
        ctx.fillStyle = "rgba(200,230,255,0.9)";
        ctx.beginPath();
        ctx.arc(0, -14, 9, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "rgba(0,180,255,0.5)";
        ctx.beginPath();
        ctx.arc(0, -14, 6, 0, Math.PI*2);
        ctx.fill();

        // Suit body
        ctx.fillStyle = "#dde8f0";
        ctx.fillRect(-6, -5, 12, 16);

        // Arms
        if(this.carrying){
            // Arms reaching up to hold the crate
            ctx.fillStyle = "#ccd8e4";
            ctx.fillRect(-10, -22, 4, 14);
            ctx.fillRect( 6, -22, 4, 14);
        } else {
            // Swinging arms
            const armSwing = walking ? Math.sin(t * 0.015) * 4 : 0;
            ctx.fillStyle = "#ccd8e4";
            ctx.fillRect(-10, -3 + armSwing, 4, 10);
            ctx.fillRect( 6, -3 - armSwing, 4, 10);
        }

        // Legs with step animation
        if(walking){
            const step = Math.sin(t * 0.015);
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8 + step*3);
            ctx.fillRect( 1, 11, 4, 8 - step*3);

            // Tiny dust puffs at feet
            if(Math.random() > 0.7){
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = "#aaa";
                ctx.beginPath();
                ctx.arc(step > 0 ? -3 : 3, 20, 2 + Math.random()*2, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        } else {
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8);
            ctx.fillRect( 1, 11, 4, 8);
        }

        // Resource crate above head
        if(this.carrying){
            ctx.fillStyle = "#cc8800";
            ctx.strokeStyle = "#aa6600";
            ctx.lineWidth = 1;
            if(ctx.roundRect){
                ctx.beginPath();
                ctx.roundRect(-7, -32, 14, 10, 2);
                ctx.fill();
                ctx.stroke();
            } else {
                ctx.fillRect(-7, -32, 14, 10);
                ctx.strokeRect(-7, -32, 14, 10);
            }
            ctx.fillStyle = "rgba(255,200,0,0.5)";
            ctx.fillRect(-5, -30, 10, 6);

            // Cross straps on crate
            ctx.strokeStyle = "#886600";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(-7, -32); ctx.lineTo(7, -22);
            ctx.moveTo(7, -32); ctx.lineTo(-7, -22);
            ctx.stroke();
        }

        ctx.restore();
    }
}

const astronaut = new Astronaut();

// =============================
// AI
// =============================
function chooseNext(){
    const now = performance.now();
    const shouldLog = (now - lastChooseLog) > CHOOSE_LOG_INTERVAL;

    if(!ship.spawned){
        if(shouldLog){ dbg('chooseNext: ship not spawned yet', 'skip'); lastChooseLog = now; }
        return;
    }
    if(ship.state !== "idle"){
        if(shouldLog){ dbg(`chooseNext: skipped â€” state=${ship.state}`, 'skip'); lastChooseLog = now; }
        return;
    }
    if(ship.holdTimer < ship.HOLD_DURATION){
        if(shouldLog){ dbg(`chooseNext: hold timer ${(ship.holdTimer/1000).toFixed(1)}s / ${(ship.HOLD_DURATION/1000).toFixed(1)}s`, 'skip'); lastChooseLog = now; }
        return;
    }

    const c = center();
    const SUN_SAFE_RADIUS = 160;

    let best = null, bestScore = 0;

    if(shouldLog) dbg(`â”€â”€ AI eval  O2=${ship.resources.oxygen.toFixed(0)} H2O=${ship.resources.water.toFixed(0)} FOOD=${ship.resources.food.toFixed(0)} FUEL=${ship.resources.fuel.toFixed(0)} INT=${ship.integrity.toFixed(0)}`, 'info');

    for(let p of planets){
        const pp = p.position();
        const distToSun = Math.hypot(pp.x - c.x, pp.y - c.y);

        if(distToSun < SUN_SAFE_RADIUS){
            if(shouldLog) dbg(`  SKIP ${p.name}: too close to sun (${distToSun.toFixed(0)} < ${SUN_SAFE_RADIUS})`, 'skip');
            continue;
        }

        if(p.resource === "repair"){
            if(ship.integrity < 20){
                if(shouldLog) dbg(`  EMERGENCY â†’ Repair (integrity ${ship.integrity.toFixed(0)} < 20)`, 'crit');
                best = p; break;
            }
            const intNeed = 100 - ship.integrity;
            if(intNeed <= 0){
                if(shouldLog) dbg(`  SKIP Repair: integrity full`, 'skip');
                continue;
            }
            const dist = ship.distanceTo(pp);
            const distPenalty = Math.max(0.3, 1 - dist / 1500);
            const score = intNeed * 3.5 * distPenalty;
            if(shouldLog) dbg(`  Repair: need=${intNeed.toFixed(0)} dist=${dist.toFixed(0)} penalty=${distPenalty.toFixed(2)} â†’ score=${score.toFixed(1)}`, 'score');
            if(score > bestScore){ bestScore = score; best = p; }
            continue;
        }

        const need = 100 - ship.resources[p.resource];

        if(p.resource === "oxygen" && ship.resources.oxygen < 15){
            if(shouldLog) dbg(`  EMERGENCY â†’ Oxygen (O2=${ship.resources.oxygen.toFixed(0)} < 15)`, 'crit');
            best = p; break;
        }

        let weight = 1;
        if(p.resource === "oxygen") weight = 1;
        if(p.resource === "fuel")   weight = 2.5;
        if(p.resource === "water")  weight = 2;

        const dist = ship.distanceTo(pp);
        const distPenalty = Math.max(0.3, 1 - dist / 1500);
        const score = need * weight * distPenalty;
        if(shouldLog) dbg(`  ${p.name}: need=${need.toFixed(0)} w=${weight} dist=${dist.toFixed(0)} penalty=${distPenalty.toFixed(2)} â†’ score=${score.toFixed(1)}`, 'score');
        if(score > bestScore){ bestScore = score; best = p; }
    }

    if(best && (bestScore > 15 || (best.resource === "oxygen" && ship.resources.oxygen < 15) || (best.resource === "repair" && ship.integrity < 20))){
        dbg(`â–¶ DECISION: GO TO ${best.name.toUpperCase()} (score=${bestScore.toFixed(1)})`, 'good');
        ship.target = best;
        ship.state = "transfer";
    } else if(shouldLog){
        if(best){
            dbg(`  No target chosen â€” bestScore=${bestScore.toFixed(1)} < 15 threshold`, 'warn');
        } else {
            dbg(`  No valid target found at all`, 'warn');
        }
    }

    if(shouldLog) lastChooseLog = now;
}

// =============================
// GAME OVER
// =============================
let gameOver = false;
const RESOURCE_NAMES = { oxygen:'OXYGEN', water:'WATER', food:'FOOD', fuel:'FUEL', integrity:'HULL INTEGRITY' };

function triggerGameOver(resource){
    gameOver = true;
    document.getElementById('gameover-reason').textContent =
        RESOURCE_NAMES[resource] + ' DEPLETED â€” CREW LOST';
    document.getElementById('gameover').classList.add('active');
}

// =============================
// MAIN LOOP
// =============================
let last = 0;
function loop(t){
    if(gameOver) return;
    const dt = Math.min(t - last, 50);
    last = t;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Stars â€” screen-fixed, no camera transform
    drawStars(t);

    // Smooth zoom toward target
    camera.zoom += (camera.targetZoom - camera.zoom) * Math.min(1, 0.06 * dt / 16);

    // World â€” apply camera
    if(camera.follow && ship.spawned){
        const targetPanX = (canvas.width  / 2 - ship.x) * camera.zoom;
        const targetPanY = (canvas.height / 2 - ship.y) * camera.zoom;
        const lerpSpeed = Math.min(1, 0.08 * dt / 16);
        camera.panX += (targetPanX - camera.panX) * lerpSpeed;
        camera.panY += (targetPanY - camera.panY) * lerpSpeed;
    }

    ctx.save();
    applyCamera();

    drawSun(t);

    for(let p of planets){ p.update(dt); p.draw(t); }

    trail.update(dt);
    trail.draw();

    updateSpawnParticles(dt);
    drawSpawnParticles();

    updateDustParticles(dt);
    drawDustParticles();

    ship.update(dt);
    astronaut.update(dt);
    pkg.update(dt);
    chooseNext();

    // Oxygen warning monitor
    if(ship.spawned && !gameOver){
        const oxy = ship.resources.oxygen;
        const now2 = performance.now();
        if(oxy < 30 && (now2 - lastOxyWarn) > 3000){
            lastOxyWarn = now2;
            const lvl = oxy < 10 ? 'crit' : oxy < 20 ? 'warn' : 'info';
            dbg(`âš  O2 WARNING: ${oxy.toFixed(0)}% â€” state=${ship.state}${ship.target ? ' target='+ship.target.name : ''}`, lvl);
        }
    }

    // Draw package before ship/astronaut so it's behind them
    pkg.draw(t);
    ship.draw();
    astronaut.draw(t);

    ctx.restore();

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
